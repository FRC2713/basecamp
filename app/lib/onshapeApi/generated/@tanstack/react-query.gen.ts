// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { abortTransaction, addAttachment, addFeature, addGlobalPermissionsForIdentity, addItemsToPublication, addItemToPublication, addPartStudioFeature, addUserToCompany, bulkCreateElement, cancelPurchaseNew, clearGlobalPermissions, commitTransactions, compareAppElementJson, comparePartStudios, consumePurchase, copyAssociativeData, copyElementFromSourceDocument, copyWorkspace, createAlias, createAssembly, createAssemblyExportGltf, createAssemblyExportObj, createAssemblyExportSolidworks, createAssemblyExportStep, createBlobTranslation, createComment, createDocument, createDrawingAppElement, createDrawingTranslation, createElement, createFeatureStudio, createInstance, createItem, createObsoletionPackage, createPartStudio, createPartStudioExportGltf, createPartStudioExportObj, createPartStudioExportSolidworks, createPartStudioExportStep, createPartStudioTranslation, createPublication, createReference, createReleasePackage, createTableTemplate, createTask, createTranslation, createVariableStudio, createVersion, createWebhook, createWorkspace, decodeConfiguration, deleteAlias, deleteAppElementContent, deleteAppElementContentBatch, deleteApplicationThumbnails, deleteAppSettings, deleteAssociativeData, deleteAttachments, deleteBlobSubelement, deleteComment, deleteCompanyAppSettings, deleteDocument, deleteElement, deleteFeature, deleteInstance, deleteItem, deletePartStudioFeature, deletePublication, deletePublicationItem, deleteReference, deleteRevisionHistory, deleteTableTemplate, deleteTranslation, deleteWorkspace, downloadBlobSubelement, downloadBlobSubelementWorkspace, downloadExternalData, downloadFileWorkspace, encodeConfigurationMap, enumerateObjectWorkflows, enumerateRevisions, evalFeatureScript, export2Json, exportParasolid, exportPartGltf, exportPartStudioGltf, exportPartStudioStl, exportPs, exportStl, find, findCompany, getActionItems, getActiveWorkflows, getAlias, getAliasesInCompany, getAliasMembers, getAllInDocument, getAllInDocumentVersion, getAllowedApprovers, getAllTranslatorFormats, getAllVersions, getAppElementHistory, getApplicableExtensionsForClient, getAssemblyBoundingBoxes, getAssemblyDefinition, getAssemblyMassProperties, getAssemblyShadedViews, getAssociativeData, getAttachment, getAuditLog, getBendTable, getBillOfMaterials, getBlobSubelementIds, getBodyDetails, getBoundingBoxes, getByCompanyId, getByDocumentId, getCategoryProperties, getClientPlans, getComment, getComments, getCompany, getCompanyAppSettings, getConfiguration, getCurrentMicroversion, getDisplayStates, getDocument, getDocumentAcl, getDocumentContents, getDocumentHistory, getDocumentPermissionSet, getDocuments, getDocumentsByName, getDocumentThumbnail, getDocumentThumbnailWithSize, getDocumentTranslations, getDocumentVersions, getDocumentWorkspaces, getDrawingTranslatorFormats, getDrawingViewJsonGeometry1, getDrawingViews1, getEdges, getElementsInDocument, getElementThumbnail, getElementThumbnailWithApiConfiguration, getElementThumbnailWithSize, getElementTransactions, getElementTranslatorFormatsByVersionOrWorkspace, getExplodedViews, getFaces1, getFeatures, getFeatureScriptRepresentation, getFeatureScriptTable, getFeatureSpecs, getFeatureStudioContents, getFeatureStudioSpecs, getFolderAcl, getFullAssemblyMetadata, getInsertables, getItem, getItems, getJson, getJsonPaths, getLatestInDocument, getLatestInDocumentOrCompany, getMassProperties, getMateValues, getMembers, getModificationStatus, getNamedPositions, getNamedViews, getOpenApi, getOrCreateBillOfMaterialsElement, getParameterValuesForId, getPartShadedViews, getPartStudioBodyDetails, getPartStudioBoundingBoxes, getPartStudioEdges, getPartStudioFaces, getPartStudioFeatures, getPartStudioFeatureSpecs, getPartStudioMassProperties, getPartStudioNamedViews, getPartStudioShadedViews, getPartsWmv, getPartsWmve, getPlanPurchases, getPublicationItems, getPurchases, getReleasePackage, getRevisionByPartNumber, getRevisionHistoryInCompanyByElementId, getRevisionHistoryInCompanyByPartId, getRevisionHistoryInCompanyByPartNumber, getSketchBoundingBoxes, getSketchInfo, getStandardContentList, getSubElementContent, getSubElementContentBatch, getSubelementIds, getTableTemplate, getTags, getTask, getTeam, getTessellatedEntities, getThumbnailForDocument, getThumbnailForDocumentAndVersion, getThumbnailForDocumentAndVersionOld, getThumbnailForDocumentOld, getTranslation, getUnitInfo, getUserAppSettings, getUserSettings, getUserSettingsCurrentLoggedInUser, getValidRuleOptions, getVariables, getVariableStudioReferences, getVariableStudioScope, getVeopStandardContentMetadata, getVersion, getWebhook, getWebhooks, getWmveMetadata, getWmvepMetadata, getWmvepsMetadata, getWmvesMetadata, getWorkflowById, getWvMetadata, insertTransformedInstances, mergeIntoWorkspace, mergePreview, modify, modifyDrawing, moveElementsToDocument, nextNumbers, type Options, pingWebhook, postAssociativeData, removeUserFromCompany, reopen, resolve, resolveAllElementReferences, resolveReference, resolveReferences, restoreFromHistory, revertUnchangedToRevisions, search, session, sessionInfo, setApplicationElementThumbnail, setCustomParameters, setVariables, setVariableStudioReferences, setVariableStudioScope, share, shareDocument, shareWithSupport, startTransaction, syncAppElements, transformOccurrences, transitionTask, translateFormat, translateIds, unregisterWebhook, unShare, unShareDocument, unshareFromSupport, updateAlias, updateAnonymousAccess, updateAppCompanySettings, updateAppElement, updateAppSettings, updateComment, updateCompanyUser, updateConfiguration, updateDocumentAttributes, updateExternalReferencesToLatestDocuments, updateFeature, updateFeatures, updateFeatureStudioContents, updateItem, updateMateValues, updateNextNumbers, updatePartStudioFeature, updatePublicAccess, updatePublicationAttributes, updateReference, updateReferences, updateReleasePackage, updateRollback, updateTask, updateUnits, updateVeopStandardContentPartMetadata, updateWebhook, updateWveMetadata, updateWvepMetadata, updateWvMetadata, uploadBlobSubelement, uploadFileCreateElement, uploadFileUpdateElement } from '../sdk.gen';
import type { AbortTransactionData, AbortTransactionResponse, AddAttachmentData, AddAttachmentResponse, AddFeatureData, AddFeatureResponse, AddGlobalPermissionsForIdentityData, AddGlobalPermissionsForIdentityResponse, AddItemsToPublicationData, AddItemsToPublicationResponse, AddItemToPublicationData, AddItemToPublicationResponse, AddPartStudioFeatureData, AddPartStudioFeatureResponse, AddUserToCompanyData, AddUserToCompanyResponse, BulkCreateElementData, BulkCreateElementResponse, CancelPurchaseNewData, CancelPurchaseNewResponse, ClearGlobalPermissionsData, ClearGlobalPermissionsResponse, CommitTransactionsData, CommitTransactionsResponse, CompareAppElementJsonData, ComparePartStudiosData, ConsumePurchaseData, ConsumePurchaseResponse, CopyAssociativeDataData, CopyAssociativeDataResponse, CopyElementFromSourceDocumentData, CopyElementFromSourceDocumentResponse, CopyWorkspaceData, CopyWorkspaceResponse, CreateAliasData, CreateAliasResponse, CreateAssemblyData, CreateAssemblyExportGltfData, CreateAssemblyExportGltfResponse, CreateAssemblyExportObjData, CreateAssemblyExportObjResponse, CreateAssemblyExportSolidworksData, CreateAssemblyExportSolidworksResponse, CreateAssemblyExportStepData, CreateAssemblyExportStepResponse, CreateAssemblyResponse, CreateBlobTranslationData, CreateBlobTranslationResponse, CreateCommentData, CreateCommentResponse, CreateDocumentData, CreateDocumentResponse, CreateDrawingAppElementData, CreateDrawingAppElementResponse, CreateDrawingTranslationData, CreateDrawingTranslationResponse, CreateElementData, CreateElementResponse, CreateFeatureStudioData, CreateFeatureStudioResponse, CreateInstanceData, CreateInstanceResponse, CreateItemData, CreateItemResponse, CreateObsoletionPackageData, CreateObsoletionPackageResponse, CreatePartStudioData, CreatePartStudioExportGltfData, CreatePartStudioExportGltfResponse, CreatePartStudioExportObjData, CreatePartStudioExportObjResponse, CreatePartStudioExportSolidworksData, CreatePartStudioExportSolidworksResponse, CreatePartStudioExportStepData, CreatePartStudioExportStepResponse, CreatePartStudioResponse, CreatePartStudioTranslationData, CreatePartStudioTranslationResponse, CreatePublicationData, CreatePublicationResponse, CreateReferenceData, CreateReferenceResponse, CreateReleasePackageData, CreateReleasePackageResponse, CreateTableTemplateData, CreateTableTemplateResponse, CreateTaskData, CreateTaskResponse, CreateTranslationData, CreateTranslationResponse, CreateVariableStudioData, CreateVariableStudioResponse, CreateVersionData, CreateVersionResponse, CreateWebhookData, CreateWebhookResponse, CreateWorkspaceData, CreateWorkspaceResponse, DecodeConfigurationData, DeleteAliasData, DeleteAliasResponse, DeleteAppElementContentBatchData, DeleteAppElementContentBatchResponse, DeleteAppElementContentData, DeleteAppElementContentResponse, DeleteApplicationThumbnailsData, DeleteApplicationThumbnailsResponse, DeleteAppSettingsData, DeleteAssociativeDataData, DeleteAssociativeDataResponse, DeleteAttachmentsData, DeleteAttachmentsResponse, DeleteBlobSubelementData, DeleteBlobSubelementResponse, DeleteCommentData, DeleteCommentResponse, DeleteCompanyAppSettingsData, DeleteCompanyAppSettingsResponse, DeleteDocumentData, DeleteDocumentResponse, DeleteElementData, DeleteElementResponse, DeleteFeatureData, DeleteFeatureResponse, DeleteInstanceData, DeleteInstanceResponse, DeleteItemData, DeleteItemResponse, DeletePartStudioFeatureData, DeletePartStudioFeatureResponse, DeletePublicationData, DeletePublicationItemData, DeletePublicationItemResponse, DeletePublicationResponse, DeleteReferenceData, DeleteReferenceResponse, DeleteRevisionHistoryData, DeleteRevisionHistoryResponse, DeleteTableTemplateData, DeleteTableTemplateResponse, DeleteTranslationData, DeleteTranslationResponse, DeleteWorkspaceData, DeleteWorkspaceResponse, DownloadBlobSubelementData, DownloadBlobSubelementWorkspaceData, DownloadExternalDataData, DownloadFileWorkspaceData, EncodeConfigurationMapData, EncodeConfigurationMapResponse, EnumerateObjectWorkflowsData, EnumerateRevisionsData, EnumerateRevisionsResponse, EvalFeatureScriptData, EvalFeatureScriptResponse, Export2JsonData, Export2JsonResponse, ExportParasolidData, ExportPartGltfData, ExportPartStudioGltfData, ExportPartStudioStlData, ExportPsData, ExportStlData, FindCompanyData, FindData, FindResponse, GetActionItemsData, GetActionItemsResponse, GetActiveWorkflowsData, GetAliasData, GetAliasesInCompanyData, GetAliasesInCompanyResponse, GetAliasMembersData, GetAliasMembersResponse, GetAllInDocumentData, GetAllInDocumentVersionData, GetAllowedApproversData, GetAllTranslatorFormatsData, GetAllVersionsData, GetAppElementHistoryData, GetApplicableExtensionsForClientData, GetAssemblyBoundingBoxesData, GetAssemblyDefinitionData, GetAssemblyMassPropertiesData, GetAssemblyShadedViewsData, GetAssociativeDataData, GetAttachmentData, GetAuditLogData, GetBendTableData, GetBillOfMaterialsData, GetBlobSubelementIdsData, GetBodyDetailsData, GetBoundingBoxesData, GetByCompanyIdData, GetByDocumentIdData, GetCategoryPropertiesData, GetClientPlansData, GetCommentData, GetCommentsData, GetCommentsResponse, GetCompanyAppSettingsData, GetCompanyData, GetConfigurationData, GetCurrentMicroversionData, GetDisplayStatesData, GetDocumentAclData, GetDocumentContentsData, GetDocumentData, GetDocumentHistoryData, GetDocumentPermissionSetData, GetDocumentsByNameData, GetDocumentsData, GetDocumentsResponse, GetDocumentThumbnailData, GetDocumentThumbnailWithSizeData, GetDocumentTranslationsData, GetDocumentTranslationsResponse, GetDocumentVersionsData, GetDocumentVersionsResponse, GetDocumentWorkspacesData, GetDrawingTranslatorFormatsData, GetDrawingViewJsonGeometry1Data, GetDrawingViews1Data, GetEdgesData, GetElementsInDocumentData, GetElementThumbnailData, GetElementThumbnailWithApiConfigurationData, GetElementThumbnailWithSizeData, GetElementTransactionsData, GetElementTranslatorFormatsByVersionOrWorkspaceData, GetExplodedViewsData, GetFaces1Data, GetFeatureScriptRepresentationData, GetFeatureScriptTableData, GetFeaturesData, GetFeatureSpecsData, GetFeatureStudioContentsData, GetFeatureStudioSpecsData, GetFolderAclData, GetFullAssemblyMetadataData, GetInsertablesData, GetItemData, GetItemsData, GetItemsResponse, GetJsonData, GetJsonPathsData, GetJsonPathsResponse, GetLatestInDocumentData, GetLatestInDocumentOrCompanyData, GetMassPropertiesData, GetMateValuesData, GetMembersData, GetMembersResponse, GetModificationStatusData, GetNamedPositionsData, GetNamedViewsData, GetOpenApiData, GetOrCreateBillOfMaterialsElementData, GetOrCreateBillOfMaterialsElementResponse, GetParameterValuesForIdData, GetPartShadedViewsData, GetPartStudioBodyDetailsData, GetPartStudioBoundingBoxesData, GetPartStudioEdgesData, GetPartStudioFacesData, GetPartStudioFeaturesData, GetPartStudioFeatureSpecsData, GetPartStudioMassPropertiesData, GetPartStudioNamedViewsData, GetPartStudioShadedViewsData, GetPartsWmvData, GetPartsWmveData, GetPlanPurchasesData, GetPlanPurchasesResponse, GetPublicationItemsData, GetPurchasesData, GetReleasePackageData, GetRevisionByPartNumberData, GetRevisionHistoryInCompanyByElementIdData, GetRevisionHistoryInCompanyByPartIdData, GetRevisionHistoryInCompanyByPartNumberData, GetSketchBoundingBoxesData, GetSketchInfoData, GetStandardContentListData, GetSubElementContentBatchData, GetSubElementContentData, GetSubelementIdsData, GetTableTemplateData, GetTagsData, GetTaskData, GetTeamData, GetTessellatedEntitiesData, GetThumbnailForDocumentAndVersionData, GetThumbnailForDocumentAndVersionOldData, GetThumbnailForDocumentData, GetThumbnailForDocumentOldData, GetTranslationData, GetUnitInfoData, GetUserAppSettingsData, GetUserSettingsCurrentLoggedInUserData, GetUserSettingsData, GetValidRuleOptionsData, GetVariablesData, GetVariableStudioReferencesData, GetVariableStudioScopeData, GetVeopStandardContentMetadataData, GetVersionData, GetWebhookData, GetWebhooksData, GetWebhooksResponse, GetWmveMetadataData, GetWmvepMetadataData, GetWmvepsMetadataData, GetWmvesMetadataData, GetWorkflowByIdData, GetWvMetadataData, InsertTransformedInstancesData, InsertTransformedInstancesResponse, MergeIntoWorkspaceData, MergeIntoWorkspaceResponse, MergePreviewData, ModifyData, ModifyDrawingData, ModifyDrawingResponse, ModifyResponse, MoveElementsToDocumentData, MoveElementsToDocumentResponse, NextNumbersData, NextNumbersResponse, PingWebhookData, PingWebhookResponse, PostAssociativeDataData, PostAssociativeDataResponse, RemoveUserFromCompanyData, RemoveUserFromCompanyResponse, ReopenData, ReopenResponse, ResolveAllElementReferencesData, ResolveData, ResolveReferenceData, ResolveReferencesData, ResolveResponse, RestoreFromHistoryData, RestoreFromHistoryResponse, RevertUnchangedToRevisionsData, RevertUnchangedToRevisionsResponse, SearchData, SearchResponse, SessionData, SessionInfoData, SessionResponse, SetApplicationElementThumbnailData, SetApplicationElementThumbnailResponse, SetCustomParametersData, SetCustomParametersResponse, SetVariablesData, SetVariablesResponse, SetVariableStudioReferencesData, SetVariableStudioReferencesResponse, SetVariableStudioScopeData, SetVariableStudioScopeResponse, ShareData, ShareDocumentData, ShareDocumentResponse, ShareResponse, ShareWithSupportData, ShareWithSupportResponse, StartTransactionData, StartTransactionResponse, SyncAppElementsData, SyncAppElementsResponse, TransformOccurrencesData, TransformOccurrencesResponse, TransitionTaskData, TransitionTaskResponse, TranslateFormatData, TranslateFormatResponse, TranslateIdsData, TranslateIdsResponse, UnregisterWebhookData, UnregisterWebhookResponse, UnShareData, UnShareDocumentData, UnShareDocumentResponse, UnshareFromSupportData, UnshareFromSupportResponse, UnShareResponse, UpdateAliasData, UpdateAliasResponse, UpdateAnonymousAccessData, UpdateAnonymousAccessResponse, UpdateAppCompanySettingsData, UpdateAppCompanySettingsResponse, UpdateAppElementData, UpdateAppElementResponse, UpdateAppSettingsData, UpdateAppSettingsResponse, UpdateCommentData, UpdateCommentResponse, UpdateCompanyUserData, UpdateCompanyUserResponse, UpdateConfigurationData, UpdateConfigurationResponse, UpdateDocumentAttributesData, UpdateDocumentAttributesResponse, UpdateExternalReferencesToLatestDocumentsData, UpdateExternalReferencesToLatestDocumentsResponse, UpdateFeatureData, UpdateFeatureResponse, UpdateFeaturesData, UpdateFeaturesResponse, UpdateFeatureStudioContentsData, UpdateFeatureStudioContentsResponse, UpdateItemData, UpdateItemResponse, UpdateMateValuesData, UpdateMateValuesResponse, UpdateNextNumbersData, UpdateNextNumbersResponse, UpdatePartStudioFeatureData, UpdatePartStudioFeatureResponse, UpdatePublicAccessData, UpdatePublicAccessResponse, UpdatePublicationAttributesData, UpdatePublicationAttributesResponse, UpdateReferenceData, UpdateReferenceResponse, UpdateReferencesData, UpdateReferencesResponse, UpdateReleasePackageData, UpdateReleasePackageResponse, UpdateRollbackData, UpdateRollbackResponse, UpdateTaskData, UpdateTaskResponse, UpdateUnitsData, UpdateUnitsResponse, UpdateVeopStandardContentPartMetadataData, UpdateVeopStandardContentPartMetadataResponse, UpdateWebhookData, UpdateWebhookResponse, UpdateWveMetadataData, UpdateWveMetadataResponse, UpdateWvepMetadataData, UpdateWvepMetadataResponse, UpdateWvMetadataData, UpdateWvMetadataResponse, UploadBlobSubelementData, UploadBlobSubelementResponse, UploadFileCreateElementData, UploadFileCreateElementResponse, UploadFileUpdateElementData, UploadFileUpdateElementResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getPlanPurchasesQueryKey = (options: Options<GetPlanPurchasesData>) => createQueryKey('getPlanPurchases', options);

/**
 * Get a list of all app purchases made for the specified plan.
 */
export const getPlanPurchasesOptions = (options: Options<GetPlanPurchasesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPlanPurchases({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPlanPurchasesQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getPlanPurchasesInfiniteQueryKey = (options: Options<GetPlanPurchasesData>): QueryKey<Options<GetPlanPurchasesData>> => createQueryKey('getPlanPurchases', options, true);

/**
 * Get a list of all app purchases made for the specified plan.
 */
export const getPlanPurchasesInfiniteOptions = (options: Options<GetPlanPurchasesData>) => {
    return infiniteQueryOptions<GetPlanPurchasesResponse, DefaultError, InfiniteData<GetPlanPurchasesResponse>, QueryKey<Options<GetPlanPurchasesData>>, number | Pick<QueryKey<Options<GetPlanPurchasesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetPlanPurchasesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getPlanPurchases({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPlanPurchasesInfiniteQueryKey(options)
    });
};

export const getPurchasesQueryKey = (options?: Options<GetPurchasesData>) => createQueryKey('getPurchases', options);

/**
 * Get a list of all app purchases made by the current user.
 *
 * This API should be used within the context of an OAuth-enabled application.
 */
export const getPurchasesOptions = (options?: Options<GetPurchasesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPurchases({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPurchasesQueryKey(options)
    });
};

/**
 * Mark a purchase as consumed by the current user.
 */
export const consumePurchaseMutation = (options?: Partial<Options<ConsumePurchaseData>>): UseMutationOptions<ConsumePurchaseResponse, DefaultError, Options<ConsumePurchaseData>> => {
    const mutationOptions: UseMutationOptions<ConsumePurchaseResponse, DefaultError, Options<ConsumePurchaseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await consumePurchase({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel a recurring subscription for the specified account ID and purchase ID.
 */
export const cancelPurchaseNewMutation = (options?: Partial<Options<CancelPurchaseNewData>>): UseMutationOptions<CancelPurchaseNewResponse, DefaultError, Options<CancelPurchaseNewData>> => {
    const mutationOptions: UseMutationOptions<CancelPurchaseNewResponse, DefaultError, Options<CancelPurchaseNewData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelPurchaseNew({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAliasesInCompanyQueryKey = (options?: Options<GetAliasesInCompanyData>) => createQueryKey('getAliasesInCompany', options);

/**
 * Get a list of all aliases that exist for your enterprise.
 */
export const getAliasesInCompanyOptions = (options?: Options<GetAliasesInCompanyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAliasesInCompany({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAliasesInCompanyQueryKey(options)
    });
};

export const getAliasesInCompanyInfiniteQueryKey = (options?: Options<GetAliasesInCompanyData>): QueryKey<Options<GetAliasesInCompanyData>> => createQueryKey('getAliasesInCompany', options, true);

/**
 * Get a list of all aliases that exist for your enterprise.
 */
export const getAliasesInCompanyInfiniteOptions = (options?: Options<GetAliasesInCompanyData>) => {
    return infiniteQueryOptions<GetAliasesInCompanyResponse, DefaultError, InfiniteData<GetAliasesInCompanyResponse>, QueryKey<Options<GetAliasesInCompanyData>>, number | Pick<QueryKey<Options<GetAliasesInCompanyData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAliasesInCompanyData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAliasesInCompany({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAliasesInCompanyInfiniteQueryKey(options)
    });
};

/**
 * Create an alias in your enterprise.
 *
 * `Manage users and teams` global permission is required to call this API.
 */
export const createAliasMutation = (options?: Partial<Options<CreateAliasData>>): UseMutationOptions<CreateAliasResponse, DefaultError, Options<CreateAliasData>> => {
    const mutationOptions: UseMutationOptions<CreateAliasResponse, DefaultError, Options<CreateAliasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAlias({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an alias from your enterprise.
 *
 * `Manage users and teams` global permission is required to call this API.
 */
export const deleteAliasMutation = (options?: Partial<Options<DeleteAliasData>>): UseMutationOptions<DeleteAliasResponse, DefaultError, Options<DeleteAliasData>> => {
    const mutationOptions: UseMutationOptions<DeleteAliasResponse, DefaultError, Options<DeleteAliasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAlias({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAliasQueryKey = (options: Options<GetAliasData>) => createQueryKey('getAlias', options);

/**
 * Get an alias by ID.
 *
 * Get the information for an alias ID.
 */
export const getAliasOptions = (options: Options<GetAliasData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAlias({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAliasQueryKey(options)
    });
};

/**
 * Add, remove, replace, or rename entries in an alias list.
 *
 * `Manage users and teams` global permission is required to call this API.
 * * Add new users in the `additions` array.
 * * Remove existing users in the `removals` array. Attempts to remove a user that does not exist in the Alias list will have no effect.
 * * Replace the entire Alias list with the `entries` array.
 * * You can also update the alias' `name` and `description`.
 * For example, given an Alias with members userA and userB:
 * * `additions: [userC]` results in [userA, userB, userC]
 * * `removals: [userB]` results in [userA]
 * * `entries: [userC, user D]` results in [userC, userD]
 */
export const updateAliasMutation = (options?: Partial<Options<UpdateAliasData>>): UseMutationOptions<UpdateAliasResponse, DefaultError, Options<UpdateAliasData>> => {
    const mutationOptions: UseMutationOptions<UpdateAliasResponse, DefaultError, Options<UpdateAliasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAlias({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAliasMembersQueryKey = (options: Options<GetAliasMembersData>) => createQueryKey('getAliasMembers', options);

/**
 * Get all users and teams assigned to an alias.
 *
 * This is a search-like endpoint that returns a subset of the member list. Use `getAlias` to return all members every time it's called.
 */
export const getAliasMembersOptions = (options: Options<GetAliasMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAliasMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAliasMembersQueryKey(options)
    });
};

export const getAliasMembersInfiniteQueryKey = (options: Options<GetAliasMembersData>): QueryKey<Options<GetAliasMembersData>> => createQueryKey('getAliasMembers', options, true);

/**
 * Get all users and teams assigned to an alias.
 *
 * This is a search-like endpoint that returns a subset of the member list. Use `getAlias` to return all members every time it's called.
 */
export const getAliasMembersInfiniteOptions = (options: Options<GetAliasMembersData>) => {
    return infiniteQueryOptions<GetAliasMembersResponse, DefaultError, InfiniteData<GetAliasMembersResponse>, QueryKey<Options<GetAliasMembersData>>, number | Pick<QueryKey<Options<GetAliasMembersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAliasMembersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAliasMembers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAliasMembersInfiniteQueryKey(options)
    });
};

/**
 * Create a new application element.
 */
export const createElementMutation = (options?: Partial<Options<CreateElementData>>): UseMutationOptions<CreateElementResponse, DefaultError, Options<CreateElementData>> => {
    const mutationOptions: UseMutationOptions<CreateElementResponse, DefaultError, Options<CreateElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create multiple empty application elements at once.
 *
 * Call this faster API instead of creating multiple app elements one at a time or in parallel.
 */
export const bulkCreateElementMutation = (options?: Partial<Options<BulkCreateElementData>>): UseMutationOptions<BulkCreateElementResponse, DefaultError, Options<BulkCreateElementData>> => {
    const mutationOptions: UseMutationOptions<BulkCreateElementResponse, DefaultError, Options<BulkCreateElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await bulkCreateElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a blob subelement from an app element.
 */
export const deleteBlobSubelementMutation = (options?: Partial<Options<DeleteBlobSubelementData>>): UseMutationOptions<DeleteBlobSubelementResponse, DefaultError, Options<DeleteBlobSubelementData>> => {
    const mutationOptions: UseMutationOptions<DeleteBlobSubelementResponse, DefaultError, Options<DeleteBlobSubelementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBlobSubelement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadBlobSubelementWorkspaceQueryKey = (options: Options<DownloadBlobSubelementWorkspaceData>) => createQueryKey('downloadBlobSubelementWorkspace', options);

/**
 * Download the blob element (i.e., a file) stored in an app element in a document's workspace.
 *
 * The downloaded file can be used to retrieve stored subelements.
 */
export const downloadBlobSubelementWorkspaceOptions = (options: Options<DownloadBlobSubelementWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadBlobSubelementWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadBlobSubelementWorkspaceQueryKey(options)
    });
};

/**
 * Create a new blob subelement from an uploaded file.
 *
 * Request body parameters are multipart fields, so you must use `"Content-Type":"multipart/form-data"` in the request header.
 */
export const uploadBlobSubelementMutation = (options?: Partial<Options<UploadBlobSubelementData>>): UseMutationOptions<UploadBlobSubelementResponse, DefaultError, Options<UploadBlobSubelementData>> => {
    const mutationOptions: UseMutationOptions<UploadBlobSubelementResponse, DefaultError, Options<UploadBlobSubelementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadBlobSubelement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Copy associative data from one view to another.
 *
 * Can only be copied between tabs in the same document. You can manage associativity with [translateIds](https://cad.onshape.com/glassworks/explorer/#/PartStudio/translateIds).
 */
export const copyAssociativeDataMutation = (options?: Partial<Options<CopyAssociativeDataData>>): UseMutationOptions<CopyAssociativeDataResponse, DefaultError, Options<CopyAssociativeDataData>> => {
    const mutationOptions: UseMutationOptions<CopyAssociativeDataResponse, DefaultError, Options<CopyAssociativeDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await copyAssociativeData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getElementTransactionsQueryKey = (options: Options<GetElementTransactionsData>) => createQueryKey('getElementTransactions', options);

/**
 * Get a list of all transactions performed on an element.
 */
export const getElementTransactionsOptions = (options: Options<GetElementTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getElementTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getElementTransactionsQueryKey(options)
    });
};

/**
 * Start a transaction
 *
 * Creates a microbranch (i.e., a branch for a new microversion).
 */
export const startTransactionMutation = (options?: Partial<Options<StartTransactionData>>): UseMutationOptions<StartTransactionResponse, DefaultError, Options<StartTransactionData>> => {
    const mutationOptions: UseMutationOptions<StartTransactionResponse, DefaultError, Options<StartTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await startTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Abort a transaction.
 *
 * Deletes a microbranch (i.e., the branch with the microversion for the transaction).
 */
export const abortTransactionMutation = (options?: Partial<Options<AbortTransactionData>>): UseMutationOptions<AbortTransactionResponse, DefaultError, Options<AbortTransactionData>> => {
    const mutationOptions: UseMutationOptions<AbortTransactionResponse, DefaultError, Options<AbortTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await abortTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Merge multiple transactions into one microversion.
 *
 * If successful, all transactions will be committed to a single microversion. If the call raises an error, nothing will be committed.
 */
export const commitTransactionsMutation = (options?: Partial<Options<CommitTransactionsData>>): UseMutationOptions<CommitTransactionsResponse, DefaultError, Options<CommitTransactionsData>> => {
    const mutationOptions: UseMutationOptions<CommitTransactionsResponse, DefaultError, Options<CommitTransactionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await commitTransactions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadBlobSubelementQueryKey = (options: Options<DownloadBlobSubelementData>) => createQueryKey('downloadBlobSubelement', options);

/**
 * Download a blob subelement from the specified app element.
 *
 * Download a blob subelement as a file.
 */
export const downloadBlobSubelementOptions = (options: Options<DownloadBlobSubelementData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadBlobSubelement({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadBlobSubelementQueryKey(options)
    });
};

/**
 * Delete the associative data from the specified app element.
 *
 * You can manage associativity with [translateIds](https://cad.onshape.com/glassworks/explorer/#/PartStudio/translateIds).
 */
export const deleteAssociativeDataMutation = (options?: Partial<Options<DeleteAssociativeDataData>>): UseMutationOptions<DeleteAssociativeDataResponse, DefaultError, Options<DeleteAssociativeDataData>> => {
    const mutationOptions: UseMutationOptions<DeleteAssociativeDataResponse, DefaultError, Options<DeleteAssociativeDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAssociativeData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAssociativeDataQueryKey = (options: Options<GetAssociativeDataData>) => createQueryKey('getAssociativeData', options);

/**
 * Get the associative data for the specified app element.
 *
 * You can manage associativity with [translateIds](https://cad.onshape.com/glassworks/explorer/#/PartStudio/translateIds).
 */
export const getAssociativeDataOptions = (options: Options<GetAssociativeDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAssociativeData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssociativeDataQueryKey(options)
    });
};

/**
 * Set the associative data for the specified app element.
 *
 * You can manage associativity with [translateIds](https://cad.onshape.com/glassworks/explorer/#/PartStudio/translateIds).
 */
export const postAssociativeDataMutation = (options?: Partial<Options<PostAssociativeDataData>>): UseMutationOptions<PostAssociativeDataResponse, DefaultError, Options<PostAssociativeDataData>> => {
    const mutationOptions: UseMutationOptions<PostAssociativeDataResponse, DefaultError, Options<PostAssociativeDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAssociativeData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBlobSubelementIdsQueryKey = (options: Options<GetBlobSubelementIdsData>) => createQueryKey('getBlobSubelementIds', options);

/**
 * Get a list of all blob subelement IDs for the specified workspace, version, or microversion.
 */
export const getBlobSubelementIdsOptions = (options: Options<GetBlobSubelementIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBlobSubelementIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBlobSubelementIdsQueryKey(options)
    });
};

export const compareAppElementJsonQueryKey = (options: Options<CompareAppElementJsonData>) => createQueryKey('compareAppElementJson', options);

/**
 * Compare app element JSON trees between workspaces/versions/microversions in a document.
 *
 * Specify the source workspace/version/microversion in the URL and specify the target workspace/version/microversion in the query parameters.
 */
export const compareAppElementJsonOptions = (options: Options<CompareAppElementJsonData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await compareAppElementJson({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: compareAppElementJsonQueryKey(options)
    });
};

export const getSubElementContentQueryKey = (options: Options<GetSubElementContentData>) => createQueryKey('getSubElementContent', options);

/**
 * Get a list of all subelement IDs in a specified workspace/version/microversion.
 */
export const getSubElementContentOptions = (options: Options<GetSubElementContentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubElementContent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubElementContentQueryKey(options)
    });
};

/**
 * Update the content for the specified app element.
 */
export const updateAppElementMutation = (options?: Partial<Options<UpdateAppElementData>>): UseMutationOptions<UpdateAppElementResponse, DefaultError, Options<UpdateAppElementData>> => {
    const mutationOptions: UseMutationOptions<UpdateAppElementResponse, DefaultError, Options<UpdateAppElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAppElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAppElementHistoryQueryKey = (options: Options<GetAppElementHistoryData>) => createQueryKey('getAppElementHistory', options);

/**
 * Get the history of the specified all element.
 */
export const getAppElementHistoryOptions = (options: Options<GetAppElementHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAppElementHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAppElementHistoryQueryKey(options)
    });
};

export const getSubelementIdsQueryKey = (options: Options<GetSubelementIdsData>) => createQueryKey('getSubelementIds', options);

/**
 * Get a list of all subelement IDs in a specified workspace/version/microversion.
 */
export const getSubelementIdsOptions = (options: Options<GetSubelementIdsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubelementIds({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubelementIdsQueryKey(options)
    });
};

export const getJsonQueryKey = (options: Options<GetJsonData>) => createQueryKey('getJson', options);

/**
 * Get the full JSON tree for the specified workspace/version/microversion.
 */
export const getJsonOptions = (options: Options<GetJsonData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getJson({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getJsonQueryKey(options)
    });
};

/**
 * Get the JSON at specified paths for an element.
 *
 * Use this endpoint to return the JSON at the specified path instead of returning the entire JSON for the element. This POST endpoint does not write any information.
 */
export const getJsonPathsMutation = (options?: Partial<Options<GetJsonPathsData>>): UseMutationOptions<GetJsonPathsResponse, DefaultError, Options<GetJsonPathsData>> => {
    const mutationOptions: UseMutationOptions<GetJsonPathsResponse, DefaultError, Options<GetJsonPathsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await getJsonPaths({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete multiple subelements array by document ID, workspace or version or microversion ID, tab ID, and subelement IDs.
 */
export const deleteAppElementContentBatchMutation = (options?: Partial<Options<DeleteAppElementContentBatchData>>): UseMutationOptions<DeleteAppElementContentBatchResponse, DefaultError, Options<DeleteAppElementContentBatchData>> => {
    const mutationOptions: UseMutationOptions<DeleteAppElementContentBatchResponse, DefaultError, Options<DeleteAppElementContentBatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAppElementContentBatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSubElementContentBatchQueryKey = (options: Options<GetSubElementContentBatchData>) => createQueryKey('getSubElementContentBatch', options);

/**
 * Get a list of multiple subelements by document ID, workspace or version or microversion ID, tab ID, and subelement IDs.
 */
export const getSubElementContentBatchOptions = (options: Options<GetSubElementContentBatchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubElementContentBatch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubElementContentBatchQueryKey(options)
    });
};

/**
 * Deletes the content from the specified app element.
 */
export const deleteAppElementContentMutation = (options?: Partial<Options<DeleteAppElementContentData>>): UseMutationOptions<DeleteAppElementContentResponse, DefaultError, Options<DeleteAppElementContentData>> => {
    const mutationOptions: UseMutationOptions<DeleteAppElementContentResponse, DefaultError, Options<DeleteAppElementContentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAppElementContent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Creates a reference to an app element.
 */
export const createReferenceMutation = (options?: Partial<Options<CreateReferenceData>>): UseMutationOptions<CreateReferenceResponse, DefaultError, Options<CreateReferenceData>> => {
    const mutationOptions: UseMutationOptions<CreateReferenceResponse, DefaultError, Options<CreateReferenceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createReference({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an app element reference.
 */
export const deleteReferenceMutation = (options?: Partial<Options<DeleteReferenceData>>): UseMutationOptions<DeleteReferenceResponse, DefaultError, Options<DeleteReferenceData>> => {
    const mutationOptions: UseMutationOptions<DeleteReferenceResponse, DefaultError, Options<DeleteReferenceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteReference({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resolveReferenceQueryKey = (options: Options<ResolveReferenceData>) => createQueryKey('resolveReference', options);

/**
 * Resolves a single reference to an app element.
 *
 * For single operations only. Use `resolveReferences` for bulk operations.
 */
export const resolveReferenceOptions = (options: Options<ResolveReferenceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveReference({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveReferenceQueryKey(options)
    });
};

/**
 * Update an app element reference.
 */
export const updateReferenceMutation = (options?: Partial<Options<UpdateReferenceData>>): UseMutationOptions<UpdateReferenceResponse, DefaultError, Options<UpdateReferenceData>> => {
    const mutationOptions: UseMutationOptions<UpdateReferenceResponse, DefaultError, Options<UpdateReferenceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateReference({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resolveReferencesQueryKey = (options: Options<ResolveReferencesData>) => createQueryKey('resolveReferences', options);

/**
 * Resolves bulk app element references.
 *
 * For bulk operations only. Use `resolveReference` for a single operation.
 */
export const resolveReferencesOptions = (options: Options<ResolveReferencesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveReferences({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveReferencesQueryKey(options)
    });
};

export const resolveAllElementReferencesQueryKey = (options: Options<ResolveAllElementReferencesData>) => createQueryKey('resolveAllElementReferences', options);

/**
 * Resolves bulk app element references.
 *
 * Resolve all references for all workspace elements. For bulk operations  only. Use `resolveReferences` for a single element.
 */
export const resolveAllElementReferencesOptions = (options: Options<ResolveAllElementReferencesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveAllElementReferences({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveAllElementReferencesQueryKey(options)
    });
};

/**
 * Delete a company's application preference settings.
 *
 * This API is only usable with an OAuth token and only by the current user or admin.
 */
export const deleteCompanyAppSettingsMutation = (options?: Partial<Options<DeleteCompanyAppSettingsData>>): UseMutationOptions<DeleteCompanyAppSettingsResponse, DefaultError, Options<DeleteCompanyAppSettingsData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompanyAppSettingsResponse, DefaultError, Options<DeleteCompanyAppSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompanyAppSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompanyAppSettingsQueryKey = (options: Options<GetCompanyAppSettingsData>) => createQueryKey('getCompanyAppSettings', options);

/**
 * Get company-level preference settings for an application.
 *
 * This API is only usable with an OAuth token and only by the current user or admin.
 */
export const getCompanyAppSettingsOptions = (options: Options<GetCompanyAppSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCompanyAppSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCompanyAppSettingsQueryKey(options)
    });
};

/**
 * Update company preference settings for an application.
 *
 * This API is only usable with an OAuth token and only by the current user or admin.
 * * Add or update a setting identified by key with value.
 * * Operation and field may optionally be specified when updating Map type settings.
 * * Field specifies the key of the setting Map to update.
 * * Operation may be one of:
 * * `ADD`: Add or update an existing field of the settings Map.
 * * `UPDATE`: Update an existing field of the settings Map and return an error if the field does not exist.
 * * `REMOVE`: Remove the field from the settings Map.
 *
 */
export const updateAppCompanySettingsMutation = (options?: Partial<Options<UpdateAppCompanySettingsData>>): UseMutationOptions<UpdateAppCompanySettingsResponse, DefaultError, Options<UpdateAppCompanySettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateAppCompanySettingsResponse, DefaultError, Options<UpdateAppCompanySettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAppCompanySettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a user's application preference settings.
 *
 * This API is only usable with an OAuth token and only by the current user or admin.
 */
export const deleteAppSettingsMutation = (options?: Partial<Options<DeleteAppSettingsData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteAppSettingsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteAppSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAppSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserAppSettingsQueryKey = (options: Options<GetUserAppSettingsData>) => createQueryKey('getUserAppSettings', options);

/**
 * Get user-level preference settings for an application.
 *
 * This API is only usable with an OAuth token and only by the current user or admin.
 */
export const getUserAppSettingsOptions = (options: Options<GetUserAppSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserAppSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserAppSettingsQueryKey(options)
    });
};

/**
 * Update a user's application preference settings.
 *
 * This API is only usable with an OAuth token and only by the current user or admin.
 * * Add or update a setting identified by key with value.
 * * Operation and field may optionally be specified when updating Map type settings.
 * * Field specifies the key of the setting Map to update.
 * * Operation may be one of:
 * * `ADD`: Add or update an existing field of the settings Map.
 * * `UPDATE`: Update an existing field of the settings Map and return an error if the field does not exist.
 * * `REMOVE`: Remove the field from the settings Map.
 *
 */
export const updateAppSettingsMutation = (options?: Partial<Options<UpdateAppSettingsData>>): UseMutationOptions<UpdateAppSettingsResponse, DefaultError, Options<UpdateAppSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateAppSettingsResponse, DefaultError, Options<UpdateAppSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAppSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApplicableExtensionsForClientQueryKey = (options: Options<GetApplicableExtensionsForClientData>) => createQueryKey('getApplicableExtensionsForClient', options);

/**
 * Get a list of the client extensions the specified user has granted/accepted terms for.
 */
export const getApplicableExtensionsForClientOptions = (options: Options<GetApplicableExtensionsForClientData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApplicableExtensionsForClient({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApplicableExtensionsForClientQueryKey(options)
    });
};

export const getNamedViewsQueryKey = (options: Options<GetNamedViewsData>) => createQueryKey('getNamedViews', options);

/**
 * Get the view data for all named views for the specified element.
 */
export const getNamedViewsOptions = (options: Options<GetNamedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNamedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNamedViewsQueryKey(options)
    });
};

/**
 * Create a new assembly tab in the document.
 */
export const createAssemblyMutation = (options?: Partial<Options<CreateAssemblyData>>): UseMutationOptions<CreateAssemblyResponse, DefaultError, Options<CreateAssemblyData>> => {
    const mutationOptions: UseMutationOptions<CreateAssemblyResponse, DefaultError, Options<CreateAssemblyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAssembly({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Gets the Bill Of Materials (BOM) for the specified assembly, or creates a BOM if none exist.
 */
export const getOrCreateBillOfMaterialsElementMutation = (options?: Partial<Options<GetOrCreateBillOfMaterialsElementData>>): UseMutationOptions<GetOrCreateBillOfMaterialsElementResponse, DefaultError, Options<GetOrCreateBillOfMaterialsElementData>> => {
    const mutationOptions: UseMutationOptions<GetOrCreateBillOfMaterialsElementResponse, DefaultError, Options<GetOrCreateBillOfMaterialsElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await getOrCreateBillOfMaterialsElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a feature from an assembly.
 */
export const deleteFeatureMutation = (options?: Partial<Options<DeleteFeatureData>>): UseMutationOptions<DeleteFeatureResponse, DefaultError, Options<DeleteFeatureData>> => {
    const mutationOptions: UseMutationOptions<DeleteFeatureResponse, DefaultError, Options<DeleteFeatureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteFeature({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update an existing feature for an Assembly.
 */
export const updateFeatureMutation = (options?: Partial<Options<UpdateFeatureData>>): UseMutationOptions<UpdateFeatureResponse, DefaultError, Options<UpdateFeatureData>> => {
    const mutationOptions: UseMutationOptions<UpdateFeatureResponse, DefaultError, Options<UpdateFeatureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFeature({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an instance of an assembly.
 */
export const deleteInstanceMutation = (options?: Partial<Options<DeleteInstanceData>>): UseMutationOptions<DeleteInstanceResponse, DefaultError, Options<DeleteInstanceData>> => {
    const mutationOptions: UseMutationOptions<DeleteInstanceResponse, DefaultError, Options<DeleteInstanceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteInstance({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Insert an instance of a part, sketch, assembly, or Part Studio into an assembly.
 *
 * Part Studio instances may include multiple parts.
 */
export const createInstanceMutation = (options?: Partial<Options<CreateInstanceData>>): UseMutationOptions<CreateInstanceResponse, DefaultError, Options<CreateInstanceData>> => {
    const mutationOptions: UseMutationOptions<CreateInstanceResponse, DefaultError, Options<CreateInstanceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createInstance({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update mate values for the given mates in the specified assembly.
 *
 * * The input mates must support motion along the provided input degrees of freedom; otherwise, the input mate value will be ignored.
 * * Values associated with multiple allowed degrees of freedom for a mate can be updated simultaneously.
 * * Values associated with multiple mate features can be updated simultaneously.
 */
export const updateMateValuesMutation = (options?: Partial<Options<UpdateMateValuesData>>): UseMutationOptions<UpdateMateValuesResponse, DefaultError, Options<UpdateMateValuesData>> => {
    const mutationOptions: UseMutationOptions<UpdateMateValuesResponse, DefaultError, Options<UpdateMateValuesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateMateValues({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Modify an assembly.
 *
 * This endpoint can include multiple modifications to an assembly with one change. For example, it can delete/suppress/unsuppress/transform multiple instances. It creates one history entry in the document history list.
 */
export const modifyMutation = (options?: Partial<Options<ModifyData>>): UseMutationOptions<ModifyResponse, DefaultError, Options<ModifyData>> => {
    const mutationOptions: UseMutationOptions<ModifyResponse, DefaultError, Options<ModifyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await modify({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Transform a list of assembly occurrences.
 */
export const transformOccurrencesMutation = (options?: Partial<Options<TransformOccurrencesData>>): UseMutationOptions<TransformOccurrencesResponse, DefaultError, Options<TransformOccurrencesData>> => {
    const mutationOptions: UseMutationOptions<TransformOccurrencesResponse, DefaultError, Options<TransformOccurrencesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await transformOccurrences({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create new instances with transformation.
 */
export const insertTransformedInstancesMutation = (options?: Partial<Options<InsertTransformedInstancesData>>): UseMutationOptions<InsertTransformedInstancesResponse, DefaultError, Options<InsertTransformedInstancesData>> => {
    const mutationOptions: UseMutationOptions<InsertTransformedInstancesResponse, DefaultError, Options<InsertTransformedInstancesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await insertTransformedInstances({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAssemblyDefinitionQueryKey = (options: Options<GetAssemblyDefinitionData>) => createQueryKey('getAssemblyDefinition', options);

/**
 * Get definition information for the specified assembly.
 *
 * All coordinates and translation matrix components are in meters (m).
 */
export const getAssemblyDefinitionOptions = (options: Options<GetAssemblyDefinitionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAssemblyDefinition({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssemblyDefinitionQueryKey(options)
    });
};

export const getBillOfMaterialsQueryKey = (options: Options<GetBillOfMaterialsData>) => createQueryKey('getBillOfMaterials', options);

/**
 * Get the Bill Of Materials (BOM) content for the specified assembly.
 *
 * Returns the BOM in JSON in the Onshape BOM Standard format.
 */
export const getBillOfMaterialsOptions = (options: Options<GetBillOfMaterialsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBillOfMaterials({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBillOfMaterialsQueryKey(options)
    });
};

export const getAssemblyBoundingBoxesQueryKey = (options: Options<GetAssemblyBoundingBoxesData>) => createQueryKey('getAssemblyBoundingBoxes', options);

/**
 * Get bounding box information for the specified assembly.
 */
export const getAssemblyBoundingBoxesOptions = (options: Options<GetAssemblyBoundingBoxesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAssemblyBoundingBoxes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssemblyBoundingBoxesQueryKey(options)
    });
};

export const getDisplayStatesQueryKey = (options: Options<GetDisplayStatesData>) => createQueryKey('getDisplayStates', options);

/**
 * Get a list of display states for the specified assembly.
 */
export const getDisplayStatesOptions = (options: Options<GetDisplayStatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDisplayStates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDisplayStatesQueryKey(options)
    });
};

export const getExplodedViewsQueryKey = (options: Options<GetExplodedViewsData>) => createQueryKey('getExplodedViews', options);

/**
 * Get a list of exploded views for the specified assembly.
 */
export const getExplodedViewsOptions = (options: Options<GetExplodedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getExplodedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getExplodedViewsQueryKey(options)
    });
};

export const getFeaturesQueryKey = (options: Options<GetFeaturesData>) => createQueryKey('getFeatures', options);

/**
 * Get the definitions of the specified features in an assembly.
 */
export const getFeaturesOptions = (options: Options<GetFeaturesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeatures({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeaturesQueryKey(options)
    });
};

/**
 * Add a feature to the assembly feature list.
 */
export const addFeatureMutation = (options?: Partial<Options<AddFeatureData>>): UseMutationOptions<AddFeatureResponse, DefaultError, Options<AddFeatureData>> => {
    const mutationOptions: UseMutationOptions<AddFeatureResponse, DefaultError, Options<AddFeatureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addFeature({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFeatureSpecsQueryKey = (options: Options<GetFeatureSpecsData>) => createQueryKey('getFeatureSpecs', options);

/**
 * Get the feature spec definitions for an assembly.
 */
export const getFeatureSpecsOptions = (options: Options<GetFeatureSpecsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeatureSpecs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeatureSpecsQueryKey(options)
    });
};

export const getAssemblyMassPropertiesQueryKey = (options: Options<GetAssemblyMassPropertiesData>) => createQueryKey('getAssemblyMassProperties', options);

/**
 * Get the mass properties for the assembly.
 *
 * The assembly must contain parts that have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-asmb.htm).
 * When three values are returned:
 * * The first is the calculated value.
 * * The second is the minimum possible value, considering tolerance.
 * * The third is the maximum possible value, considering tolerance.
 */
export const getAssemblyMassPropertiesOptions = (options: Options<GetAssemblyMassPropertiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAssemblyMassProperties({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssemblyMassPropertiesQueryKey(options)
    });
};

export const getNamedPositionsQueryKey = (options: Options<GetNamedPositionsData>) => createQueryKey('getNamedPositions', options);

/**
 * Get a list of all named positions for the assembly.
 */
export const getNamedPositionsOptions = (options: Options<GetNamedPositionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNamedPositions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNamedPositionsQueryKey(options)
    });
};

export const getAssemblyShadedViewsQueryKey = (options: Options<GetAssemblyShadedViewsData>) => createQueryKey('getAssemblyShadedViews', options);

/**
 * Get an array of shaded view images for the document.
 */
export const getAssemblyShadedViewsOptions = (options: Options<GetAssemblyShadedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAssemblyShadedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssemblyShadedViewsQueryKey(options)
    });
};

/**
 * Export the assembly to glTF.
 *
 * Creates an asynchronous export of the assembly. See [API Guide: Import & Export](https://onshape-public.github.io/docs/api-adv/translation/#export-an-assembly-to-gltf-obj-solidworks-or-step) for details.
 */
export const createAssemblyExportGltfMutation = (options?: Partial<Options<CreateAssemblyExportGltfData>>): UseMutationOptions<CreateAssemblyExportGltfResponse, DefaultError, Options<CreateAssemblyExportGltfData>> => {
    const mutationOptions: UseMutationOptions<CreateAssemblyExportGltfResponse, DefaultError, Options<CreateAssemblyExportGltfData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAssemblyExportGltf({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Export the assembly to OBJ.
 *
 * Creates an asynchronous export of the assembly. See [API Guide: Import & Export](https://onshape-public.github.io/docs/api-adv/translation/#export-an-assembly-to-gltf-obj-solidworks-or-step) for details.
 */
export const createAssemblyExportObjMutation = (options?: Partial<Options<CreateAssemblyExportObjData>>): UseMutationOptions<CreateAssemblyExportObjResponse, DefaultError, Options<CreateAssemblyExportObjData>> => {
    const mutationOptions: UseMutationOptions<CreateAssemblyExportObjResponse, DefaultError, Options<CreateAssemblyExportObjData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAssemblyExportObj({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Export the assembly to Solidworks.
 *
 * Creates an asynchronous export of the assembly. See [API Guide: Import & Export](https://onshape-public.github.io/docs/api-adv/translation/#export-an-assembly-to-gltf-obj-solidworks-or-step) for details.
 */
export const createAssemblyExportSolidworksMutation = (options?: Partial<Options<CreateAssemblyExportSolidworksData>>): UseMutationOptions<CreateAssemblyExportSolidworksResponse, DefaultError, Options<CreateAssemblyExportSolidworksData>> => {
    const mutationOptions: UseMutationOptions<CreateAssemblyExportSolidworksResponse, DefaultError, Options<CreateAssemblyExportSolidworksData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAssemblyExportSolidworks({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Export the assembly to STEP.
 *
 * Creates an asynchronous export of the assembly. See [API Guide: Import & Export](https://onshape-public.github.io/docs/api-adv/translation/#export-an-assembly-to-gltf-obj-solidworks-or-step) for details.
 */
export const createAssemblyExportStepMutation = (options?: Partial<Options<CreateAssemblyExportStepData>>): UseMutationOptions<CreateAssemblyExportStepResponse, DefaultError, Options<CreateAssemblyExportStepData>> => {
    const mutationOptions: UseMutationOptions<CreateAssemblyExportStepResponse, DefaultError, Options<CreateAssemblyExportStepData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAssemblyExportStep({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMateValuesQueryKey = (options: Options<GetMateValuesData>) => createQueryKey('getMateValues', options);

/**
 * Get a list of mate values in the specified assembly.
 *
 * Describes the relative position of the first mate connector with respect to the second along the designated degrees of freedom (DOF) for mates in the specified assembly.
 */
export const getMateValuesOptions = (options: Options<GetMateValuesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMateValues({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMateValuesQueryKey(options)
    });
};

/**
 * Export the assembly to another format.
 *
 * Creates an asynchronous export. Use format-specific export endpoints where available.
 * * Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats](#/Translation/getAllTranslatorFormats) to get a list of valid export file formats. Confirm that `couldBeAssembly=true.`
 * * Set `storeInDocument` to `false` to export to a data file. Set to `true` to export to a blob element in the same document.
 * * See [API Guide: Import & Export ](https://onshape-public.github.io/docs/api-adv/translation/#export-an-assembly-to-another-format) for more details.
 */
export const translateFormatMutation = (options?: Partial<Options<TranslateFormatData>>): UseMutationOptions<TranslateFormatResponse, DefaultError, Options<TranslateFormatData>> => {
    const mutationOptions: UseMutationOptions<TranslateFormatResponse, DefaultError, Options<TranslateFormatData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await translateFormat({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getClientPlansQueryKey = (options: Options<GetClientPlansData>) => createQueryKey('getClientPlans', options);

/**
 * Get all billing plans and their information for an application by client ID.
 *
 * This API should be used within the context of an OAuth-enabled application.
 */
export const getClientPlansOptions = (options: Options<GetClientPlansData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getClientPlans({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getClientPlansQueryKey(options)
    });
};

/**
 * Upload a file and create a blob element from it.
 *
 * Request body parameters are multipart fields, so you must use `"Content-Type":"multipart/form-data"` in the request header.
 */
export const uploadFileCreateElementMutation = (options?: Partial<Options<UploadFileCreateElementData>>): UseMutationOptions<UploadFileCreateElementResponse, DefaultError, Options<UploadFileCreateElementData>> => {
    const mutationOptions: UseMutationOptions<UploadFileCreateElementResponse, DefaultError, Options<UploadFileCreateElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadFileCreateElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadFileWorkspaceQueryKey = (options: Options<DownloadFileWorkspaceData>) => createQueryKey('downloadFileWorkspace', options);

/**
 * Download a file from a blob element for the specified workspace/version/microversion.
 *
 * See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
 */
export const downloadFileWorkspaceOptions = (options: Options<DownloadFileWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadFileWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadFileWorkspaceQueryKey(options)
    });
};

/**
 * Update a blob element by uploading a file.
 *
 * Request body parameters are multipart fields, so you must use `"Content-Type":"multipart/form-data"` in the request header.
 */
export const uploadFileUpdateElementMutation = (options?: Partial<Options<UploadFileUpdateElementData>>): UseMutationOptions<UploadFileUpdateElementResponse, DefaultError, Options<UploadFileUpdateElementData>> => {
    const mutationOptions: UseMutationOptions<UploadFileUpdateElementResponse, DefaultError, Options<UploadFileUpdateElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadFileUpdateElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Change the measurement units for the blob element.
 */
export const updateUnitsMutation = (options?: Partial<Options<UpdateUnitsData>>): UseMutationOptions<UpdateUnitsResponse, DefaultError, Options<UpdateUnitsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUnitsResponse, DefaultError, Options<UpdateUnitsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUnits({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Export a blob element to another format.
 *
 * * Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats]#/Translation/getAllTranslatorFormats) to get a list of valid export file formats.
 * * Set `storeInDocument` to `false` to export to a data file. Set to `true` to export to a blob element in the same document.
 * * See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
 */
export const createBlobTranslationMutation = (options?: Partial<Options<CreateBlobTranslationData>>): UseMutationOptions<CreateBlobTranslationResponse, DefaultError, Options<CreateBlobTranslationData>> => {
    const mutationOptions: UseMutationOptions<CreateBlobTranslationResponse, DefaultError, Options<CreateBlobTranslationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBlobTranslation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCommentsQueryKey = (options?: Options<GetCommentsData>) => createQueryKey('getComments', options);

/**
 * Get a list of comments in a document.
 */
export const getCommentsOptions = (options?: Options<GetCommentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getComments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentsQueryKey(options)
    });
};

export const getCommentsInfiniteQueryKey = (options?: Options<GetCommentsData>): QueryKey<Options<GetCommentsData>> => createQueryKey('getComments', options, true);

/**
 * Get a list of comments in a document.
 */
export const getCommentsInfiniteOptions = (options?: Options<GetCommentsData>) => {
    return infiniteQueryOptions<GetCommentsResponse, DefaultError, InfiniteData<GetCommentsResponse>, QueryKey<Options<GetCommentsData>>, number | Pick<QueryKey<Options<GetCommentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCommentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getComments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentsInfiniteQueryKey(options)
    });
};

/**
 * Update a document with a new comment.
 */
export const createCommentMutation = (options?: Partial<Options<CreateCommentData>>): UseMutationOptions<CreateCommentResponse, DefaultError, Options<CreateCommentData>> => {
    const mutationOptions: UseMutationOptions<CreateCommentResponse, DefaultError, Options<CreateCommentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createComment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a comment from a document.
 */
export const deleteCommentMutation = (options?: Partial<Options<DeleteCommentData>>): UseMutationOptions<DeleteCommentResponse, DefaultError, Options<DeleteCommentData>> => {
    const mutationOptions: UseMutationOptions<DeleteCommentResponse, DefaultError, Options<DeleteCommentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteComment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCommentQueryKey = (options: Options<GetCommentData>) => createQueryKey('getComment', options);

/**
 * Get details for a comment.
 */
export const getCommentOptions = (options: Options<GetCommentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getComment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentQueryKey(options)
    });
};

/**
 * Update the content of an existing comment.
 */
export const updateCommentMutation = (options?: Partial<Options<UpdateCommentData>>): UseMutationOptions<UpdateCommentResponse, DefaultError, Options<UpdateCommentData>> => {
    const mutationOptions: UseMutationOptions<UpdateCommentResponse, DefaultError, Options<UpdateCommentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateComment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete all attachments from a comment.
 */
export const deleteAttachmentsMutation = (options?: Partial<Options<DeleteAttachmentsData>>): UseMutationOptions<DeleteAttachmentsResponse, DefaultError, Options<DeleteAttachmentsData>> => {
    const mutationOptions: UseMutationOptions<DeleteAttachmentsResponse, DefaultError, Options<DeleteAttachmentsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAttachments({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add an attachment to a comment.
 */
export const addAttachmentMutation = (options?: Partial<Options<AddAttachmentData>>): UseMutationOptions<AddAttachmentResponse, DefaultError, Options<AddAttachmentData>> => {
    const mutationOptions: UseMutationOptions<AddAttachmentResponse, DefaultError, Options<AddAttachmentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addAttachment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAttachmentQueryKey = (options: Options<GetAttachmentData>) => createQueryKey('getAttachment', options);

/**
 * Get the attachment with the specified file extension that is associated with the specified comment.
 *
 * Returns only a single attachment.
 */
export const getAttachmentOptions = (options: Options<GetAttachmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAttachment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAttachmentQueryKey(options)
    });
};

/**
 * Reopen a resolved comment.
 */
export const reopenMutation = (options?: Partial<Options<ReopenData>>): UseMutationOptions<ReopenResponse, DefaultError, Options<ReopenData>> => {
    const mutationOptions: UseMutationOptions<ReopenResponse, DefaultError, Options<ReopenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reopen({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resolve a comment.
 */
export const resolveMutation = (options?: Partial<Options<ResolveData>>): UseMutationOptions<ResolveResponse, DefaultError, Options<ResolveData>> => {
    const mutationOptions: UseMutationOptions<ResolveResponse, DefaultError, Options<ResolveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resolve({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findCompanyQueryKey = (options?: Options<FindCompanyData>) => createQueryKey('findCompany', options);

/**
 * Get all companies to which the specified user belongs.
 *
 * If no user is specified, will return all companies associated with the current user.
 */
export const findCompanyOptions = (options?: Options<FindCompanyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findCompany({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findCompanyQueryKey(options)
    });
};

export const getCompanyQueryKey = (options: Options<GetCompanyData>) => createQueryKey('getCompany', options);

/**
 * Get company information by company ID.
 */
export const getCompanyOptions = (options: Options<GetCompanyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCompany({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCompanyQueryKey(options)
    });
};

export const getDocumentsByNameQueryKey = (options: Options<GetDocumentsByNameData>) => createQueryKey('getDocumentsByName', options);

/**
 * Get document by exact document name.
 *
 * This API can only be called by company admins. Use the `name` field for the exact document name string.
 */
export const getDocumentsByNameOptions = (options: Options<GetDocumentsByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentsByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentsByNameQueryKey(options)
    });
};

/**
 * Remove global permissions for a company user or team.
 *
 * Clear all or some of a user's global permissions
 */
export const clearGlobalPermissionsMutation = (options?: Partial<Options<ClearGlobalPermissionsData>>): UseMutationOptions<ClearGlobalPermissionsResponse, DefaultError, Options<ClearGlobalPermissionsData>> => {
    const mutationOptions: UseMutationOptions<ClearGlobalPermissionsResponse, DefaultError, Options<ClearGlobalPermissionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await clearGlobalPermissions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add one or more global permissions to company user or team.
 *
 * List of global permissions to grant. See [Onshape Help: Global Permissions](https://cad.onshape.com/help/Content/Plans/global_permissions.htm#Assignin) for details on each of the available permissions.
 * * `0`: Manage role based access control
 * * `1`: Manage users, teams, and aliases
 * * `2`: Enterprise administrator
 * * `3`: Permanently delete
 * * `4`: Analytics administrator
 * * `5`: Invite guest users
 * * `6`: Create projects
 * * `7`: Approve releases
 * * `8`: Enable link sharing
 * * `9`: Create releases
 * * `10`: Allow access to the App Store
 * * `11`: Create documents and folders in the Enterprise root
 * * `12`: Allow access to public documents
 * * `17`: Manage non-geometric items
 * * `18`: Manage workflows
 * * `19`: Transfer documents out of Enterprise
 * * `20`: Sync to Arena
 * * `21`: Create tasks
 * * `22`: Manage standard content metadata
 * * `23`: Workspace protection permissions
 * * `24`: Import files
 * * `25`: Use revision tools  * `26`: Export files
 *
 */
export const addGlobalPermissionsForIdentityMutation = (options?: Partial<Options<AddGlobalPermissionsForIdentityData>>): UseMutationOptions<AddGlobalPermissionsForIdentityResponse, DefaultError, Options<AddGlobalPermissionsForIdentityData>> => {
    const mutationOptions: UseMutationOptions<AddGlobalPermissionsForIdentityResponse, DefaultError, Options<AddGlobalPermissionsForIdentityData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addGlobalPermissionsForIdentity({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add a user to a company.
 *
 * Returns the company user info.
 */
export const addUserToCompanyMutation = (options?: Partial<Options<AddUserToCompanyData>>): UseMutationOptions<AddUserToCompanyResponse, DefaultError, Options<AddUserToCompanyData>> => {
    const mutationOptions: UseMutationOptions<AddUserToCompanyResponse, DefaultError, Options<AddUserToCompanyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addUserToCompany({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a user from a company, company teams, and all the direct shares.
 */
export const removeUserFromCompanyMutation = (options?: Partial<Options<RemoveUserFromCompanyData>>): UseMutationOptions<RemoveUserFromCompanyResponse, DefaultError, Options<RemoveUserFromCompanyData>> => {
    const mutationOptions: UseMutationOptions<RemoveUserFromCompanyResponse, DefaultError, Options<RemoveUserFromCompanyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeUserFromCompany({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update the company's information for a user.
 *
 * Returns updated company user info. `globalPermissions` field is deprecated. Please use the following:
 * * [addGlobalPermissionsForIdentity](#/Company/addGlobalPermissionsForIdentity)
 * * [clearGlobalPermissions](#/Company/clearGlobalPermissions)
 */
export const updateCompanyUserMutation = (options?: Partial<Options<UpdateCompanyUserData>>): UseMutationOptions<UpdateCompanyUserResponse, DefaultError, Options<UpdateCompanyUserData>> => {
    const mutationOptions: UseMutationOptions<UpdateCompanyUserResponse, DefaultError, Options<UpdateCompanyUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCompanyUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentsQueryKey = (options?: Options<GetDocumentsData>) => createQueryKey('getDocuments', options);

/**
 * Get a list of documents that meet the criteria you specify.
 */
export const getDocumentsOptions = (options?: Options<GetDocumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocuments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentsQueryKey(options)
    });
};

export const getDocumentsInfiniteQueryKey = (options?: Options<GetDocumentsData>): QueryKey<Options<GetDocumentsData>> => createQueryKey('getDocuments', options, true);

/**
 * Get a list of documents that meet the criteria you specify.
 */
export const getDocumentsInfiniteOptions = (options?: Options<GetDocumentsData>) => {
    return infiniteQueryOptions<GetDocumentsResponse, DefaultError, InfiniteData<GetDocumentsResponse>, QueryKey<Options<GetDocumentsData>>, number | Pick<QueryKey<Options<GetDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getDocuments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentsInfiniteQueryKey(options)
    });
};

/**
 * Create and upload a document.
 *
 * The `name` field is required in the `BTDocumentParams` schema when creating a new document.
 */
export const createDocumentMutation = (options?: Partial<Options<CreateDocumentData>>): UseMutationOptions<CreateDocumentResponse, DefaultError, Options<CreateDocumentData>> => {
    const mutationOptions: UseMutationOptions<CreateDocumentResponse, DefaultError, Options<CreateDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const downloadExternalDataQueryKey = (options: Options<DownloadExternalDataData>) => createQueryKey('downloadExternalData', options);

/**
 * Download external data file(s) associated with the document.
 *
 * * See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
 * * If downloading an exported file, poll the `requestState` in the translation response and wait for a result of `DONE` before attempting to download the file.
 * * Use the `resultExternalDataIds` from the translation response as the foreign id (`{fid}`) in this API.
 */
export const downloadExternalDataOptions = (options: Options<DownloadExternalDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadExternalData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadExternalDataQueryKey(options)
    });
};

export const getDocumentVersionsQueryKey = (options: Options<GetDocumentVersionsData>) => createQueryKey('getDocumentVersions', options);

/**
 * Retrieve versions by document ID.
 */
export const getDocumentVersionsOptions = (options: Options<GetDocumentVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsQueryKey(options)
    });
};

export const getDocumentVersionsInfiniteQueryKey = (options: Options<GetDocumentVersionsData>): QueryKey<Options<GetDocumentVersionsData>> => createQueryKey('getDocumentVersions', options, true);

/**
 * Retrieve versions by document ID.
 */
export const getDocumentVersionsInfiniteOptions = (options: Options<GetDocumentVersionsData>) => {
    return infiniteQueryOptions<GetDocumentVersionsResponse, DefaultError, InfiniteData<GetDocumentVersionsResponse>, QueryKey<Options<GetDocumentVersionsData>>, number | Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getDocumentVersions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsInfiniteQueryKey(options)
    });
};

/**
 * Create version by document ID.
 */
export const createVersionMutation = (options?: Partial<Options<CreateVersionData>>): UseMutationOptions<CreateVersionResponse, DefaultError, Options<CreateVersionData>> => {
    const mutationOptions: UseMutationOptions<CreateVersionResponse, DefaultError, Options<CreateVersionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createVersion({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVersionQueryKey = (options: Options<GetVersionData>) => createQueryKey('getVersion', options);

/**
 * Retrieve version by document ID and version ID.
 */
export const getVersionOptions = (options: Options<GetVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVersionQueryKey(options)
    });
};

/**
 * Update external references to latest by document ID, workspace ID, and tab ID.
 */
export const updateExternalReferencesToLatestDocumentsMutation = (options?: Partial<Options<UpdateExternalReferencesToLatestDocumentsData>>): UseMutationOptions<UpdateExternalReferencesToLatestDocumentsResponse, DefaultError, Options<UpdateExternalReferencesToLatestDocumentsData>> => {
    const mutationOptions: UseMutationOptions<UpdateExternalReferencesToLatestDocumentsResponse, DefaultError, Options<UpdateExternalReferencesToLatestDocumentsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateExternalReferencesToLatestDocuments({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Move tab by document ID and workspace ID.
 */
export const moveElementsToDocumentMutation = (options?: Partial<Options<MoveElementsToDocumentData>>): UseMutationOptions<MoveElementsToDocumentResponse, DefaultError, Options<MoveElementsToDocumentData>> => {
    const mutationOptions: UseMutationOptions<MoveElementsToDocumentResponse, DefaultError, Options<MoveElementsToDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await moveElementsToDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revertUnchangedToRevisionsMutation = (options?: Partial<Options<RevertUnchangedToRevisionsData>>): UseMutationOptions<RevertUnchangedToRevisionsResponse, DefaultError, Options<RevertUnchangedToRevisionsData>> => {
    const mutationOptions: UseMutationOptions<RevertUnchangedToRevisionsResponse, DefaultError, Options<RevertUnchangedToRevisionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await revertUnchangedToRevisions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const syncAppElementsMutation = (options?: Partial<Options<SyncAppElementsData>>): UseMutationOptions<SyncAppElementsResponse, DefaultError, Options<SyncAppElementsData>> => {
    const mutationOptions: UseMutationOptions<SyncAppElementsResponse, DefaultError, Options<SyncAppElementsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await syncAppElements({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentWorkspacesQueryKey = (options: Options<GetDocumentWorkspacesData>) => createQueryKey('getDocumentWorkspaces', options);

/**
 * Retrieve workspaces by document ID.
 */
export const getDocumentWorkspacesOptions = (options: Options<GetDocumentWorkspacesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentWorkspaces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentWorkspacesQueryKey(options)
    });
};

/**
 * Create workspace by document ID.
 */
export const createWorkspaceMutation = (options?: Partial<Options<CreateWorkspaceData>>): UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createWorkspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete workspace by document ID and workspace ID.
 */
export const deleteWorkspaceMutation = (options?: Partial<Options<DeleteWorkspaceData>>): UseMutationOptions<DeleteWorkspaceResponse, DefaultError, Options<DeleteWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<DeleteWorkspaceResponse, DefaultError, Options<DeleteWorkspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteWorkspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentHistoryQueryKey = (options: Options<GetDocumentHistoryData>) => createQueryKey('getDocumentHistory', options);

/**
 * Retrieve document history by document ID and workspace or microversion ID.
 */
export const getDocumentHistoryOptions = (options: Options<GetDocumentHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentHistoryQueryKey(options)
    });
};

export const getDocumentContentsQueryKey = (options: Options<GetDocumentContentsData>) => createQueryKey('getDocumentContents', options);

/**
 * Retrieve tabs and folders by document ID and workspace or version or microversion ID.
 *
 * Returns information on tabs and folders in the document.
 */
export const getDocumentContentsOptions = (options: Options<GetDocumentContentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentContents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentContentsQueryKey(options)
    });
};

export const getElementsInDocumentQueryKey = (options: Options<GetElementsInDocumentData>) => createQueryKey('getElementsInDocument', options);

/**
 * Retrieve tabs by document ID and workspace or version or microversion ID.
 *
 * This endpoint only returns the tabs and not folders in the document. Use the [getDocumentContents](#/Document/getDocumentContents) endpoint to get information about folders and tabs.
 */
export const getElementsInDocumentOptions = (options: Options<GetElementsInDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getElementsInDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getElementsInDocumentQueryKey(options)
    });
};

export const getUnitInfoQueryKey = (options: Options<GetUnitInfoData>) => createQueryKey('getUnitInfo', options);

/**
 * Get the selected units and precision by document ID and workspace or version or microversion ID.
 */
export const getUnitInfoOptions = (options: Options<GetUnitInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUnitInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUnitInfoQueryKey(options)
    });
};

export const getCurrentMicroversionQueryKey = (options: Options<GetCurrentMicroversionData>) => createQueryKey('getCurrentMicroversion', options);

/**
 * Retrieve current microversion by document ID and workspace or version ID.
 */
export const getCurrentMicroversionOptions = (options: Options<GetCurrentMicroversionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentMicroversion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentMicroversionQueryKey(options)
    });
};

/**
 * Export document by document ID, workspace or version ID, and tab ID.
 */
export const export2JsonMutation = (options?: Partial<Options<Export2JsonData>>): UseMutationOptions<Export2JsonResponse, DefaultError, Options<Export2JsonData>> => {
    const mutationOptions: UseMutationOptions<Export2JsonResponse, DefaultError, Options<Export2JsonData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await export2Json({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInsertablesQueryKey = (options: Options<GetInsertablesData>) => createQueryKey('getInsertables', options);

/**
 * Retrieve insertables by document ID and workspace or version ID.
 */
export const getInsertablesOptions = (options: Options<GetInsertablesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInsertables({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInsertablesQueryKey(options)
    });
};

/**
 * Search document.
 *
 * This returns list of documents based on search parameters.
 */
export const searchMutation = (options?: Partial<Options<SearchData>>): UseMutationOptions<SearchResponse, DefaultError, Options<SearchData>> => {
    const mutationOptions: UseMutationOptions<SearchResponse, DefaultError, Options<SearchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await search({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete document by document ID.
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Retrieve document by document ID.
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentQueryKey(options)
    });
};

/**
 * Update document attributes by document ID.
 */
export const updateDocumentAttributesMutation = (options?: Partial<Options<UpdateDocumentAttributesData>>): UseMutationOptions<UpdateDocumentAttributesResponse, DefaultError, Options<UpdateDocumentAttributesData>> => {
    const mutationOptions: UseMutationOptions<UpdateDocumentAttributesResponse, DefaultError, Options<UpdateDocumentAttributesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDocumentAttributes({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentAclQueryKey = (options: Options<GetDocumentAclData>) => createQueryKey('getDocumentAcl', options);

/**
 * Retrieve access control list by document ID.
 */
export const getDocumentAclOptions = (options: Options<GetDocumentAclData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentAcl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentAclQueryKey(options)
    });
};

/**
 * Allow or deny anonymous access to a document or publication.
 *
 * If anonymous access is allowed, you can allow or deny anonymous users the ability to export the document or publication. If `anonymousAccessAllowed=false` and `anonymousAllowsExport=true`, the call will throw an error.
 */
export const updateAnonymousAccessMutation = (options?: Partial<Options<UpdateAnonymousAccessData>>): UseMutationOptions<UpdateAnonymousAccessResponse, DefaultError, Options<UpdateAnonymousAccessData>> => {
    const mutationOptions: UseMutationOptions<UpdateAnonymousAccessResponse, DefaultError, Options<UpdateAnonymousAccessData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAnonymousAccess({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Make a document public or private.
 *
 *  * Set `public=true` in the request body to make the document public. Set to `false` to make it private. Free users cannot make documents private.
 * * The `documentId` provided in the URL must match the one provided in the request body exactly.
 */
export const updatePublicAccessMutation = (options?: Partial<Options<UpdatePublicAccessData>>): UseMutationOptions<UpdatePublicAccessResponse, DefaultError, Options<UpdatePublicAccessData>> => {
    const mutationOptions: UseMutationOptions<UpdatePublicAccessResponse, DefaultError, Options<UpdatePublicAccessData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePublicAccess({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentPermissionSetQueryKey = (options: Options<GetDocumentPermissionSetData>) => createQueryKey('getDocumentPermissionSet', options);

/**
 * Retrieve Document permissions by document ID.
 */
export const getDocumentPermissionSetOptions = (options: Options<GetDocumentPermissionSetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentPermissionSet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentPermissionSetQueryKey(options)
    });
};

/**
 * Share document by document ID.
 */
export const shareDocumentMutation = (options?: Partial<Options<ShareDocumentData>>): UseMutationOptions<ShareDocumentResponse, DefaultError, Options<ShareDocumentData>> => {
    const mutationOptions: UseMutationOptions<ShareDocumentResponse, DefaultError, Options<ShareDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await shareDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove document View permissions from a user or other entity.
 *
 * Specify the ID of the entity to unshare with in the `eid` field, and specify the type of entity being identified in the `entryType` field. For example, to unshare a document with a company, you would use `1` as the `entryType` value and the `companyId` as the `entityId`.
 */
export const unShareDocumentMutation = (options?: Partial<Options<UnShareDocumentData>>): UseMutationOptions<UnShareDocumentResponse, DefaultError, Options<UnShareDocumentData>> => {
    const mutationOptions: UseMutationOptions<UnShareDocumentResponse, DefaultError, Options<UnShareDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unShareDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unshare document with support.
 */
export const unshareFromSupportMutation = (options?: Partial<Options<UnshareFromSupportData>>): UseMutationOptions<UnshareFromSupportResponse, DefaultError, Options<UnshareFromSupportData>> => {
    const mutationOptions: UseMutationOptions<UnshareFromSupportResponse, DefaultError, Options<UnshareFromSupportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unshareFromSupport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Share document by document ID with Onshape support.
 */
export const shareWithSupportMutation = (options?: Partial<Options<ShareWithSupportData>>): UseMutationOptions<ShareWithSupportResponse, DefaultError, Options<ShareWithSupportData>> => {
    const mutationOptions: UseMutationOptions<ShareWithSupportResponse, DefaultError, Options<ShareWithSupportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await shareWithSupport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const mergePreviewQueryKey = (options: Options<MergePreviewData>) => createQueryKey('mergePreview', options);

/**
 * Merge preview of changes that will occur based on document ID, workspace ID and source workspace/version ID
 */
export const mergePreviewOptions = (options: Options<MergePreviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await mergePreview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: mergePreviewQueryKey(options)
    });
};

/**
 * Restore version or microversion to workspace by document ID, workspace ID, and version or microversion ID.
 */
export const restoreFromHistoryMutation = (options?: Partial<Options<RestoreFromHistoryData>>): UseMutationOptions<RestoreFromHistoryResponse, DefaultError, Options<RestoreFromHistoryData>> => {
    const mutationOptions: UseMutationOptions<RestoreFromHistoryResponse, DefaultError, Options<RestoreFromHistoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restoreFromHistory({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Copy workspace by document ID and workspace ID.
 */
export const copyWorkspaceMutation = (options?: Partial<Options<CopyWorkspaceData>>): UseMutationOptions<CopyWorkspaceResponse, DefaultError, Options<CopyWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<CopyWorkspaceResponse, DefaultError, Options<CopyWorkspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await copyWorkspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Merge into workspace by document ID and workspace ID.
 */
export const mergeIntoWorkspaceMutation = (options?: Partial<Options<MergeIntoWorkspaceData>>): UseMutationOptions<MergeIntoWorkspaceResponse, DefaultError, Options<MergeIntoWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<MergeIntoWorkspaceResponse, DefaultError, Options<MergeIntoWorkspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await mergeIntoWorkspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new drawing in a document.
 *
 * This endpoint takes a JSON Schema as input. See the schema docs below for details, and see [API Guide: Drawings](https://onshape-public.github.io/docs/api-adv/drawings/) for more information.
 */
export const createDrawingAppElementMutation = (options?: Partial<Options<CreateDrawingAppElementData>>): UseMutationOptions<CreateDrawingAppElementResponse, DefaultError, Options<CreateDrawingAppElementData>> => {
    const mutationOptions: UseMutationOptions<CreateDrawingAppElementResponse, DefaultError, Options<CreateDrawingAppElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDrawingAppElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Modify a drawing via JSON payload.
 *
 * See [API Guide: Drawings](https://onshape-public.github.io/docs/api-adv/drawings/) for more information.When polling for drawing modifications to complete, use a reasonable interval (e.g., avoid polling multiple times a second, use an exponential backoff strategy, etc.). See [Rate Limiting](/docs/api-adv/errors/#429) and [API Limits](/docs/auth/limits) for more information.
 */
export const modifyDrawingMutation = (options?: Partial<Options<ModifyDrawingData>>): UseMutationOptions<ModifyDrawingResponse, DefaultError, Options<ModifyDrawingData>> => {
    const mutationOptions: UseMutationOptions<ModifyDrawingResponse, DefaultError, Options<ModifyDrawingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await modifyDrawing({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDrawingTranslatorFormatsQueryKey = (options: Options<GetDrawingTranslatorFormatsData>) => createQueryKey('getDrawingTranslatorFormats', options);

/**
 * Get a list of all valid formats the drawing can be translated (exported) to.
 *
 * See [API Guide: Translations](https://onshape-public.github.io/docs/api-adv/translation/#export-a-drawing-as-a-json) for more information.
 */
export const getDrawingTranslatorFormatsOptions = (options: Options<GetDrawingTranslatorFormatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDrawingTranslatorFormats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDrawingTranslatorFormatsQueryKey(options)
    });
};

export const getDrawingViews1QueryKey = (options: Options<GetDrawingViews1Data>) => createQueryKey('getDrawingViews1', options);

/**
 * Get details of all drawing views.
 */
export const getDrawingViews1Options = (options: Options<GetDrawingViews1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDrawingViews1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDrawingViews1QueryKey(options)
    });
};

export const getDrawingViewJsonGeometry1QueryKey = (options: Options<GetDrawingViewJsonGeometry1Data>) => createQueryKey('getDrawingViewJsonGeometry1', options);

/**
 * Get view geometry of a drawing view in JSON format.
 */
export const getDrawingViewJsonGeometry1Options = (options: Options<GetDrawingViewJsonGeometry1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDrawingViewJsonGeometry1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDrawingViewJsonGeometry1QueryKey(options)
    });
};

/**
 * Translate (export) a drawing to a different format.
 *
 * Export a drawing to a different format within a document. Use `getDrawingTranslatorFormats` for a list of supported translation (i.e., import/export) formats. See [API Guide: Translations](https://onshape-public.github.io/docs/api-adv/translation/#export-a-drawing-as-a-json) for more information.
 */
export const createDrawingTranslationMutation = (options?: Partial<Options<CreateDrawingTranslationData>>): UseMutationOptions<CreateDrawingTranslationResponse, DefaultError, Options<CreateDrawingTranslationData>> => {
    const mutationOptions: UseMutationOptions<CreateDrawingTranslationResponse, DefaultError, Options<CreateDrawingTranslationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDrawingTranslation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getModificationStatusQueryKey = (options: Options<GetModificationStatusData>) => createQueryKey('getModificationStatus', options);

/**
 * Get the status of a drawing modification operation.
 */
export const getModificationStatusOptions = (options: Options<GetModificationStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getModificationStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getModificationStatusQueryKey(options)
    });
};

/**
 * Copy an element from a source document.
 *
 * Specify the target document and workspace in the URL. Specify the source document, workspace, and element in the request body.
 * If `anchorElementId` is specified, the copied element will be inserted after the anchor element. If not specified, the copied element will be inserted at the end of the tab list.
 *
 */
export const copyElementFromSourceDocumentMutation = (options?: Partial<Options<CopyElementFromSourceDocumentData>>): UseMutationOptions<CopyElementFromSourceDocumentResponse, DefaultError, Options<CopyElementFromSourceDocumentData>> => {
    const mutationOptions: UseMutationOptions<CopyElementFromSourceDocumentResponse, DefaultError, Options<CopyElementFromSourceDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await copyElementFromSourceDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Encode a configuration option for use in other API calls.
 *
 * Returns a configuration string in the following form:
 * `configuration=parameterId%3DparameterValue`
 * The configuration string can be used in other Onshape API calls to specify which configuration option to use. See the [Configuration API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for additional details.
 *
 */
export const encodeConfigurationMapMutation = (options?: Partial<Options<EncodeConfigurationMapData>>): UseMutationOptions<EncodeConfigurationMapResponse, DefaultError, Options<EncodeConfigurationMapData>> => {
    const mutationOptions: UseMutationOptions<EncodeConfigurationMapResponse, DefaultError, Options<EncodeConfigurationMapData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await encodeConfigurationMap({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an element from a document.
 *
 * Attempting to delete the last element in a document will result in an error.
 */
export const deleteElementMutation = (options?: Partial<Options<DeleteElementData>>): UseMutationOptions<DeleteElementResponse, DefaultError, Options<DeleteElementData>> => {
    const mutationOptions: UseMutationOptions<DeleteElementResponse, DefaultError, Options<DeleteElementData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteElement({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update or replace references in an element.
 */
export const updateReferencesMutation = (options?: Partial<Options<UpdateReferencesData>>): UseMutationOptions<UpdateReferencesResponse, DefaultError, Options<UpdateReferencesData>> => {
    const mutationOptions: UseMutationOptions<UpdateReferencesResponse, DefaultError, Options<UpdateReferencesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateReferences({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getConfigurationQueryKey = (options: Options<GetConfigurationData>) => createQueryKey('getConfiguration', options);

/**
 * Get the configuration definition for a Part Studio, Variable Studio, or Assembly.
 *
 * Use Configurations to create variations of elements. You can configure feature and parameter values, part properties, custom part properties, face and part appearances, and sketch text. Each Part Studio can have only one Configuration, but it can contain multiple Configuration inputs.
 * See the [Configuration API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for additional details.
 */
export const getConfigurationOptions = (options: Options<GetConfigurationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getConfiguration({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getConfigurationQueryKey(options)
    });
};

/**
 * Update the configuration definition for a Part Studio, Variable Studio, or Assembly.
 *
 * See the [Configuration API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for additional details
 */
export const updateConfigurationMutation = (options?: Partial<Options<UpdateConfigurationData>>): UseMutationOptions<UpdateConfigurationResponse, DefaultError, Options<UpdateConfigurationData>> => {
    const mutationOptions: UseMutationOptions<UpdateConfigurationResponse, DefaultError, Options<UpdateConfigurationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateConfiguration({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const decodeConfigurationQueryKey = (options: Options<DecodeConfigurationData>) => createQueryKey('decodeConfiguration', options);

/**
 * Decode a configuration string.
 *
 * Decode a configuration string into its original JSON form to obtain configuration parameter ID and value. See the [Configuration API Guide](https://onshape-public.github.io/docs/api-adv/configs/) for additional details.
 */
export const decodeConfigurationOptions = (options: Options<DecodeConfigurationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await decodeConfiguration({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: decodeConfigurationQueryKey(options)
    });
};

export const getElementTranslatorFormatsByVersionOrWorkspaceQueryKey = (options: Options<GetElementTranslatorFormatsByVersionOrWorkspaceData>) => createQueryKey('getElementTranslatorFormatsByVersionOrWorkspace', options);

/**
 * Gets the list of formats an element can be translated to or from.
 *
 * See the [Translation API Guide](https://onshape-public.github.io/docs/api-adv/translation/) for additional details.
 */
export const getElementTranslatorFormatsByVersionOrWorkspaceOptions = (options: Options<GetElementTranslatorFormatsByVersionOrWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getElementTranslatorFormatsByVersionOrWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getElementTranslatorFormatsByVersionOrWorkspaceQueryKey(options)
    });
};

export const getValidRuleOptionsQueryKey = (options: Options<GetValidRuleOptionsData>) => createQueryKey('getValidRuleOptions', options);

/**
 *  Get a list of valid export rule options for the user or company.
 *
 * Does NOT get the rules themselves; it gets the information used to create them.
 */
export const getValidRuleOptionsOptions = (options: Options<GetValidRuleOptionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getValidRuleOptions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getValidRuleOptionsQueryKey(options)
    });
};

/**
 * Create a new Feature Studio tab in a document.
 *
 * Specify the name for the new tab in the request body.
 */
export const createFeatureStudioMutation = (options?: Partial<Options<CreateFeatureStudioData>>): UseMutationOptions<CreateFeatureStudioResponse, DefaultError, Options<CreateFeatureStudioData>> => {
    const mutationOptions: UseMutationOptions<CreateFeatureStudioResponse, DefaultError, Options<CreateFeatureStudioData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createFeatureStudio({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFeatureStudioContentsQueryKey = (options: Options<GetFeatureStudioContentsData>) => createQueryKey('getFeatureStudioContents', options);

/**
 * Get the text for a Feature Studio element.
 */
export const getFeatureStudioContentsOptions = (options: Options<GetFeatureStudioContentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeatureStudioContents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeatureStudioContentsQueryKey(options)
    });
};

/**
 * Update the text for a Feature Studio element.
 */
export const updateFeatureStudioContentsMutation = (options?: Partial<Options<UpdateFeatureStudioContentsData>>): UseMutationOptions<UpdateFeatureStudioContentsResponse, DefaultError, Options<UpdateFeatureStudioContentsData>> => {
    const mutationOptions: UseMutationOptions<UpdateFeatureStudioContentsResponse, DefaultError, Options<UpdateFeatureStudioContentsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFeatureStudioContents({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFeatureStudioSpecsQueryKey = (options: Options<GetFeatureStudioSpecsData>) => createQueryKey('getFeatureStudioSpecs', options);

/**
 * Get the feature specs for a Feature Studio element.
 */
export const getFeatureStudioSpecsOptions = (options: Options<GetFeatureStudioSpecsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeatureStudioSpecs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeatureStudioSpecsQueryKey(options)
    });
};

export const getFolderAclQueryKey = (options: Options<GetFolderAclData>) => createQueryKey('getFolderAcl', options);

/**
 * Get the Access Control List (ACL) for a folder to view permissions.
 *
 * Returns the ACL of permission objects. Each object contains:
 * * The type of entity
 * * 0 (User)
 * * 1 (Company)
 * * 2 (Team)
 * * 3 (Document)
 * * 4 (Application)
 * * The ID of the entity for the specified type.
 * * The permissions for that entity.
 * *  OWNER (100): All permissions, including those not listed, such as permission to transfer ownership.
 * * DELETE (90)
 * * RESHARE (80)
 * * WRITE (70)
 * * READ (60)
 * * LINK (50)
 * * COPY (30): Can copy workspace
 * * EXPORT (20): Can export geometry
 * * COMMENT (10)
 * * ANONYMOUS_ACCESS (5): Special, restricted read access
 */
export const getFolderAclOptions = (options: Options<GetFolderAclData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFolderAcl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFolderAclQueryKey(options)
    });
};

/**
 * Share folder with an entity.
 *
 * * Specify the type of entity to share with using `entries.entryType`:
 * * 0 (User)
 * * 1 (Company)
 * * 2 (Team)
 * * 3 (Document)
 * * 4 (Application)
 * * Provide one of the identifiers in the `entries` object in the request body.
 * * You can share with non-Onshape users with the `email` field when `entryType=0`.
 * * Provide the string for the permission set. Do not include the integer in parentheses:
 * * OWNER (100): Object owner. Implies all permissions including those not listed such as permission to transfer ownership.
 * * DELETE (90)
 * * RESHARE (80)
 * * WRITE (70)
 * * READ (60)
 * * LINK (50)
 * * COPY (30): Can copy workspace
 * * EXPORT (20): Can export geometry
 * * COMMENT (10)
 * * ANONYMOUS_ACCESS (5): Special, restricted read access
 */
export const shareMutation = (options?: Partial<Options<ShareData>>): UseMutationOptions<ShareResponse, DefaultError, Options<ShareData>> => {
    const mutationOptions: UseMutationOptions<ShareResponse, DefaultError, Options<ShareData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await share({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove permissions from the folder for the specified Access Control List (ACL) entry.
 *
 * * Provide the folder ID for the folder to unshare.
 * * Provide the `entityType` for the type of entity to remove.
 * * 0 (User)
 * * 1 (Company)
 * * 2 (Team)
 * * 3 (Document)
 * * 4 (Application)
 * * Provide the entity ID in the `eid` param.
 */
export const unShareMutation = (options?: Partial<Options<UnShareData>>): UseMutationOptions<UnShareResponse, DefaultError, Options<UnShareData>> => {
    const mutationOptions: UseMutationOptions<UnShareResponse, DefaultError, Options<UnShareData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unShare({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLatestInDocumentQueryKey = (options: Options<GetLatestInDocumentData>) => createQueryKey('getLatestInDocument', options);

/**
 * Get a list of things in this document that can be inserted elsewhere.
 *
 * * Returns only the latest revision of released insertables.
 * * Use the document ID (`did`) parameter to specify the source document, not the insertion target.
 * * For example, you can insert a custom Feature library into another custom Feature library, insert Parts into an Assembly or a Drawing, etc.
 */
export const getLatestInDocumentOptions = (options: Options<GetLatestInDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestInDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestInDocumentQueryKey(options)
    });
};

export const getItemsQueryKey = (options?: Options<GetItemsData>) => createQueryKey('getItems', options);

/**
 * Get all items owned by a company/classroom/enterprise.
 *
 * Returns a list of all items owned by the company/classroom/enterprise.
 *
 * Either `documentId` or `companyId` must be provided.
 */
export const getItemsOptions = (options?: Options<GetItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemsQueryKey(options)
    });
};

export const getItemsInfiniteQueryKey = (options?: Options<GetItemsData>): QueryKey<Options<GetItemsData>> => createQueryKey('getItems', options, true);

/**
 * Get all items owned by a company/classroom/enterprise.
 *
 * Returns a list of all items owned by the company/classroom/enterprise.
 *
 * Either `documentId` or `companyId` must be provided.
 */
export const getItemsInfiniteOptions = (options?: Options<GetItemsData>) => {
    return infiniteQueryOptions<GetItemsResponse, DefaultError, InfiniteData<GetItemsResponse>, QueryKey<Options<GetItemsData>>, number | Pick<QueryKey<Options<GetItemsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetItemsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getItems({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemsInfiniteQueryKey(options)
    });
};

/**
 * Create a new item.
 */
export const createItemMutation = (options?: Partial<Options<CreateItemData>>): UseMutationOptions<CreateItemResponse, DefaultError, Options<CreateItemData>> => {
    const mutationOptions: UseMutationOptions<CreateItemResponse, DefaultError, Options<CreateItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an item.
 *
 * Items can only be deleted if `publishState = 0` (`PENDING`). [`GET /items/{iid}`](#/Items/getItem) to get the `publishState`.
 */
export const deleteItemMutation = (options?: Partial<Options<DeleteItemData>>): UseMutationOptions<DeleteItemResponse, DefaultError, Options<DeleteItemData>> => {
    const mutationOptions: UseMutationOptions<DeleteItemResponse, DefaultError, Options<DeleteItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemQueryKey = (options: Options<GetItemData>) => createQueryKey('getItem', options);

/**
 * Get item by ID.
 *
 * Either `documentId` or `companyId` must be provided, in addition to the item ID.
 */
export const getItemOptions = (options: Options<GetItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getItemQueryKey(options)
    });
};

/**
 * Update an item.
 */
export const updateItemMutation = (options?: Partial<Options<UpdateItemData>>): UseMutationOptions<UpdateItemResponse, DefaultError, Options<UpdateItemData>> => {
    const mutationOptions: UseMutationOptions<UpdateItemResponse, DefaultError, Options<UpdateItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWmvesMetadataQueryKey = (options: Options<GetWmvesMetadataData>) => createQueryKey('getWmvesMetadata', options);

/**
 * Get the metadata for all elements in a document.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * You can specify the optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
 * * `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
 * * `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
 * * `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
 * * You can also choose to include a `thumbnail`. Default value is `false`.
 */
export const getWmvesMetadataOptions = (options: Options<GetWmvesMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWmvesMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWmvesMetadataQueryKey(options)
    });
};

export const getWmveMetadataQueryKey = (options: Options<GetWmveMetadataData>) => createQueryKey('getWmveMetadata', options);

/**
 * Get the metadata for an element.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * `linkDocumentId` can be specified where applicable and this combined with the query param `inferMetadataOwner` (default value is `false`) will be used to infer metadata owner.
 * * `configuration` optional query parameter defaults to default configuration.
 * * You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
 * * `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
 * * `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
 * * You can also choose to include a `thumbnail`. Default value is `false`.
 */
export const getWmveMetadataOptions = (options: Options<GetWmveMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWmveMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWmveMetadataQueryKey(options)
    });
};

/**
 * Update the metadata for an element.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * Microversion (`m`) in `wvm` path parameter option is not supported.
 * * Specify the property metadata to update in the Request body.
 */
export const updateWveMetadataMutation = (options?: Partial<Options<UpdateWveMetadataData>>): UseMutationOptions<UpdateWveMetadataResponse, DefaultError, Options<UpdateWveMetadataData>> => {
    const mutationOptions: UseMutationOptions<UpdateWveMetadataResponse, DefaultError, Options<UpdateWveMetadataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateWveMetadata({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFullAssemblyMetadataQueryKey = (options: Options<GetFullAssemblyMetadataData>) => createQueryKey('getFullAssemblyMetadata', options);

/**
 * Get the metadata for an assembly, including supporting metadata.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * `linkDocumentId` can be specified where applicable and this combined with the query param `inferMetadataOwner` (default value is `false`) will be used to infer metadata owner.
 * * `configuration` optional query parameter defaults to default configuration.
 * * `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
 * * `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
 * * You can also choose to include a `thumbnail`. Default value is `false`.
 */
export const getFullAssemblyMetadataOptions = (options: Options<GetFullAssemblyMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFullAssemblyMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFullAssemblyMetadataQueryKey(options)
    });
};

export const getWmvepsMetadataQueryKey = (options: Options<GetWmvepsMetadataData>) => createQueryKey('getWmvepsMetadata', options);

/**
 * Get the metadata for all parts in a document.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * The `configuration` optional query parameter uses the default configuration unless otherwise specified.
 * * You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
 * * `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
 * * `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
 * * `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
 * * You can also choose to include a `thumbnail`. Default value is `false`.
 */
export const getWmvepsMetadataOptions = (options: Options<GetWmvepsMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWmvepsMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWmvepsMetadataQueryKey(options)
    });
};

export const getWmvepMetadataQueryKey = (options: Options<GetWmvepMetadataData>) => createQueryKey('getWmvepMetadata', options);

/**
 * Get the metadata for a part.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * Specify the part in the `iden` or `pid` path parameter.
 * * The `configuration` optional query parameter uses the default configuration unless otherwise specified.
 * * `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
 * * `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
 * * `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
 * * You can also choose to include a `thumbnail`. Default value is `false`.
 */
export const getWmvepMetadataOptions = (options: Options<GetWmvepMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWmvepMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWmvepMetadataQueryKey(options)
    });
};

/**
 * Update the metadata for a part.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * Specify the part in the `iden` or `pid` path parameter.
 * * The `configuration` optional query parameter uses the default configuration unless otherwise specified.
 * * `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
 * * Specify the property metadata to update in the Request body.
 */
export const updateWvepMetadataMutation = (options?: Partial<Options<UpdateWvepMetadataData>>): UseMutationOptions<UpdateWvepMetadataResponse, DefaultError, Options<UpdateWvepMetadataData>> => {
    const mutationOptions: UseMutationOptions<UpdateWvepMetadataResponse, DefaultError, Options<UpdateWvepMetadataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateWvepMetadata({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWvMetadataQueryKey = (options: Options<GetWvMetadataData>) => createQueryKey('getWvMetadata', options);

/**
 * Get the metadata for a workspace or version.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * `linkDocumentId` can be specified where applicable. Combined with `inferMetadataOwner` (default value is `false`), this is used to infer metadata owner.
 * * You can specify an optional `depth` query parameter to get multiple levels in an assembly. Default `depth` is `1`.
 * * `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
 * * `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
 * * You can also choose to include a `thumbnail`. Default value is `false`.
 */
export const getWvMetadataOptions = (options: Options<GetWvMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWvMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWvMetadataQueryKey(options)
    });
};

/**
 * Update the metadata for a workspace or version.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 */
export const updateWvMetadataMutation = (options?: Partial<Options<UpdateWvMetadataData>>): UseMutationOptions<UpdateWvMetadataResponse, DefaultError, Options<UpdateWvMetadataData>> => {
    const mutationOptions: UseMutationOptions<UpdateWvMetadataResponse, DefaultError, Options<UpdateWvMetadataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateWvMetadata({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update the metadata for a standard content part.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * Specify the document ID to update in the `did` path param.
 * * Specify the document in which you have inserted the standard content part in the `linkDocumentId` query param.
 * * Specify the property metadata to update in the Request body.
 */
export const updateVeopStandardContentPartMetadataMutation = (options?: Partial<Options<UpdateVeopStandardContentPartMetadataData>>): UseMutationOptions<UpdateVeopStandardContentPartMetadataResponse, DefaultError, Options<UpdateVeopStandardContentPartMetadataData>> => {
    const mutationOptions: UseMutationOptions<UpdateVeopStandardContentPartMetadataResponse, DefaultError, Options<UpdateVeopStandardContentPartMetadataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateVeopStandardContentPartMetadata({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVeopStandardContentMetadataQueryKey = (options: Options<GetVeopStandardContentMetadataData>) => createQueryKey('getVeopStandardContentMetadata', options);

/**
 * Get the metadata for a standard content part.
 *
 * See [API Guide: Metadata](https://onshape-public.github.io/docs/api-adv/metadata/) for details.
 * * Specify the part in the `pid` path parameter.
 * * The `configuration` and `linkDocumentId` query parameters are required.
 * * `includeComputedProperties` can be used to include or omit computed properties. Default value is `true`.
 * * `includeComputedAssemblyProperties` can be used to query computed assembly properties which are generally expensive. Default value is `false`.
 * * You can also choose to include a `thumbnail`. Default value is `false`.
 */
export const getVeopStandardContentMetadataOptions = (options: Options<GetVeopStandardContentMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVeopStandardContentMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVeopStandardContentMetadataQueryKey(options)
    });
};

export const getCategoryPropertiesQueryKey = (options?: Options<GetCategoryPropertiesData>) => createQueryKey('getCategoryProperties', options);

/**
 * Get properties associated with the specified metadata categories.
 *
 * An object's category specifies its type: Part, Assembly, Drawing, etc. Available properties depend on the object's category.
 */
export const getCategoryPropertiesOptions = (options?: Options<GetCategoryPropertiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoryProperties({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoryPropertiesQueryKey(options)
    });
};

/**
 * Send the items to generate numbers for, and return the next valid available part numbers.
 *
 * Get the next available part number. See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-the-next-available-part-number) for more details.
 */
export const nextNumbersMutation = (options?: Partial<Options<NextNumbersData>>): UseMutationOptions<NextNumbersResponse, DefaultError, Options<NextNumbersData>> => {
    const mutationOptions: UseMutationOptions<NextNumbersResponse, DefaultError, Options<NextNumbersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await nextNumbers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOpenApiQueryKey = (options?: Options<GetOpenApiData>) => createQueryKey('getOpenApi', options);

/**
 * Get the OpenAPI specification for the Onshape REST API.
 *
 * The Onshape API OpenAPI specification is returned in the JSON format.
 */
export const getOpenApiOptions = (options?: Options<GetOpenApiData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOpenApi({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOpenApiQueryKey(options)
    });
};

export const getTagsQueryKey = (options?: Options<GetTagsData>) => createQueryKey('getTags', options);

/**
 * Get the list of tags in the Onshape OpenAPI specification.
 *
 * Tags are used to group operations. For example, `Document` groups operations on documents.
 */
export const getTagsOptions = (options?: Options<GetTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagsQueryKey(options)
    });
};

/**
 * Send the items to generate numbers for, and return the next valid available part numbers.
 *
 * Get the next available part number. See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-the-next-available-part-number) for more details.
 */
export const updateNextNumbersMutation = (options?: Partial<Options<UpdateNextNumbersData>>): UseMutationOptions<UpdateNextNumbersResponse, DefaultError, Options<UpdateNextNumbersData>> => {
    const mutationOptions: UseMutationOptions<UpdateNextNumbersResponse, DefaultError, Options<UpdateNextNumbersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateNextNumbers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPartsWmvQueryKey = (options: Options<GetPartsWmvData>) => createQueryKey('getPartsWmv', options);

/**
 * Get all parts in a workspace, version, or microversion.
 */
export const getPartsWmvOptions = (options: Options<GetPartsWmvData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartsWmv({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartsWmvQueryKey(options)
    });
};

export const getPartsWmveQueryKey = (options: Options<GetPartsWmveData>) => createQueryKey('getPartsWmve', options);

/**
 * Get all parts in an element.
 */
export const getPartsWmveOptions = (options: Options<GetPartsWmveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartsWmve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartsWmveQueryKey(options)
    });
};

export const getBodyDetailsQueryKey = (options: Options<GetBodyDetailsData>) => createQueryKey('getBodyDetails', options);

/**
 * Get a part's body details.
 *
 * All coordinates are in meters (m).
 */
export const getBodyDetailsOptions = (options: Options<GetBodyDetailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBodyDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBodyDetailsQueryKey(options)
    });
};

export const getBoundingBoxesQueryKey = (options: Options<GetBoundingBoxesData>) => createQueryKey('getBoundingBoxes', options);

/**
 * Get a part's bounding box details.
 */
export const getBoundingBoxesOptions = (options: Options<GetBoundingBoxesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBoundingBoxes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBoundingBoxesQueryKey(options)
    });
};

export const exportPartGltfQueryKey = (options: Options<ExportPartGltfData>) => createQueryKey('exportPartGltf', options);

/**
 * Synchronously export a part to a glTF file.
 *
 * Creates a synchronous export of the part (with limited tessellation settings) to a glTF file.
 * * Returns a 307 redirect from which to download the exported file.
 * * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.
 * * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.
 *
 * See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
 */
export const exportPartGltfOptions = (options: Options<ExportPartGltfData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportPartGltf({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportPartGltfQueryKey(options)
    });
};

export const getMassPropertiesQueryKey = (options: Options<GetMassPropertiesData>) => createQueryKey('getMassProperties', options);

/**
 * Get a part's mass properties.
 *
 * Parts must have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-ps.htm).
 * When three values are returned:
 * * The first is the calculated value.
 * * The second is the minimum possible value, considering tolerance.
 * * The third is the maximum possible value, considering tolerance.
 */
export const getMassPropertiesOptions = (options: Options<GetMassPropertiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMassProperties({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMassPropertiesQueryKey(options)
    });
};

export const exportPsQueryKey = (options: Options<ExportPsData>) => createQueryKey('exportPs', options);

/**
 * Synchronously export a part to a Parasolid file.
 *
 * Creates a synchronous export of the part (with limited tessellation settings) to a Parasolid file.
 * * Returns a 307 redirect from which to download the exported file.
 * * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.
 * * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.
 *
 * See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
 */
export const exportPsOptions = (options: Options<ExportPsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportPs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportPsQueryKey(options)
    });
};

export const getPartShadedViewsQueryKey = (options: Options<GetPartShadedViewsData>) => createQueryKey('getPartShadedViews', options);

/**
 * Get a part's shaded views.
 */
export const getPartShadedViewsOptions = (options: Options<GetPartShadedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartShadedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartShadedViewsQueryKey(options)
    });
};

export const getBendTableQueryKey = (options: Options<GetBendTableData>) => createQueryKey('getBendTable', options);

/**
 * Get a part's sheet metal bend table.
 */
export const getBendTableOptions = (options: Options<GetBendTableData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBendTable({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBendTableQueryKey(options)
    });
};

export const exportStlQueryKey = (options: Options<ExportStlData>) => createQueryKey('exportStl', options);

/**
 * Synchronously export a part to an STL file.
 *
 * Creates a synchronous export of the part (with limited tessellation settings) to an STL file.
 * * Returns a 307 redirect from which to download the exported file.
 * * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.
 * * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.
 *
 * See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
 */
export const exportStlOptions = (options: Options<ExportStlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportStl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportStlQueryKey(options)
    });
};

export const getEdgesQueryKey = (options: Options<GetEdgesData>) => createQueryKey('getEdges', options);

/**
 * Get a list of a part's tessellation edges.
 *
 * Returns the coordinates (in meters) of each edge's endpoints.
 */
export const getEdgesOptions = (options: Options<GetEdgesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEdges({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEdgesQueryKey(options)
    });
};

export const getFaces1QueryKey = (options: Options<GetFaces1Data>) => createQueryKey('getFaces1', options);

/**
 * Get a list of a part's tessellation faces.
 *
 * Coordinates are in meters (m).
 */
export const getFaces1Options = (options: Options<GetFaces1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFaces1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFaces1QueryKey(options)
    });
};

export const getPartStudioNamedViewsQueryKey = (options: Options<GetPartStudioNamedViewsData>) => createQueryKey('getPartStudioNamedViews', options);

/**
 * Get a list of all named views that exist in the Part Studio.
 *
 * Returns a map from view name to view data for the given element. See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
 */
export const getPartStudioNamedViewsOptions = (options: Options<GetPartStudioNamedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioNamedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioNamedViewsQueryKey(options)
    });
};

/**
 * Create a new Part Studio in a document.
 *
 * See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
 */
export const createPartStudioMutation = (options?: Partial<Options<CreatePartStudioData>>): UseMutationOptions<CreatePartStudioResponse, DefaultError, Options<CreatePartStudioData>> => {
    const mutationOptions: UseMutationOptions<CreatePartStudioResponse, DefaultError, Options<CreatePartStudioData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPartStudio({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a Part Studio feature.
 *
 * See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
 */
export const deletePartStudioFeatureMutation = (options?: Partial<Options<DeletePartStudioFeatureData>>): UseMutationOptions<DeletePartStudioFeatureResponse, DefaultError, Options<DeletePartStudioFeatureData>> => {
    const mutationOptions: UseMutationOptions<DeletePartStudioFeatureResponse, DefaultError, Options<DeletePartStudioFeatureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePartStudioFeature({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update the definition of a Part Studio feature.
 *
 * Replaces an existing feature in the location of the existing feature. See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
 */
export const updatePartStudioFeatureMutation = (options?: Partial<Options<UpdatePartStudioFeatureData>>): UseMutationOptions<UpdatePartStudioFeatureResponse, DefaultError, Options<UpdatePartStudioFeatureData>> => {
    const mutationOptions: UseMutationOptions<UpdatePartStudioFeatureResponse, DefaultError, Options<UpdatePartStudioFeatureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePartStudioFeature({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Move the Feature List rollback bar in the Part Studio.
 *
 * Replace `"string"` in the request body with an object that specifies the new location for the rollback bar:
 * `{ "rollbackIndex": integer }`
 *
 * For example: `{ "rollbackIndex": 2 }`
 *
 * Set to `-1` to move the rollback bar to the end of the list.
 *
 * See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
 */
export const updateRollbackMutation = (options?: Partial<Options<UpdateRollbackData>>): UseMutationOptions<UpdateRollbackResponse, DefaultError, Options<UpdateRollbackData>> => {
    const mutationOptions: UseMutationOptions<UpdateRollbackResponse, DefaultError, Options<UpdateRollbackData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRollback({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update multiple features in a Part Studio
 *
 * This API accepts a list of features (that must already exist in the Part Studio) to update. This call does not fully redefine the features; it updates only the parameters supplied in the top-level feature structure, and optionally can update feature suppression attributes.
 * See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
 */
export const updateFeaturesMutation = (options?: Partial<Options<UpdateFeaturesData>>): UseMutationOptions<UpdateFeaturesResponse, DefaultError, Options<UpdateFeaturesData>> => {
    const mutationOptions: UseMutationOptions<UpdateFeaturesResponse, DefaultError, Options<UpdateFeaturesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateFeatures({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPartStudioBodyDetailsQueryKey = (options: Options<GetPartStudioBodyDetailsData>) => createQueryKey('getPartStudioBodyDetails', options);

/**
 * Get the body details for a Part Studio.
 *
 * See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
 */
export const getPartStudioBodyDetailsOptions = (options: Options<GetPartStudioBodyDetailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioBodyDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioBodyDetailsQueryKey(options)
    });
};

export const getPartStudioBoundingBoxesQueryKey = (options: Options<GetPartStudioBoundingBoxesData>) => createQueryKey('getPartStudioBoundingBoxes', options);

/**
 * Get the bounding boxes for a Part Studio.
 *
 * This endpoint does not result in a tight bounding box. The values returned are meant for graphics and visualization, and are approximate.
 * To calculate a tight bounding box, see the [FeatureScript API Guide](https://onshape-public.github.io/docs/api-adv/fs/#calculate-a-tight-bounding-box).
 */
export const getPartStudioBoundingBoxesOptions = (options: Options<GetPartStudioBoundingBoxesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioBoundingBoxes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioBoundingBoxesQueryKey(options)
    });
};

export const comparePartStudiosQueryKey = (options: Options<ComparePartStudiosData>) => createQueryKey('comparePartStudios', options);

/**
 * Get the differences between two Part Studios in a single document.
 */
export const comparePartStudiosOptions = (options: Options<ComparePartStudiosData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await comparePartStudios({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: comparePartStudiosQueryKey(options)
    });
};

export const getPartStudioFeaturesQueryKey = (options: Options<GetPartStudioFeaturesData>) => createQueryKey('getPartStudioFeatures', options);

/**
 * Get a list of features instantiated in the Part Studio.
 *
 * See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
 */
export const getPartStudioFeaturesOptions = (options: Options<GetPartStudioFeaturesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioFeatures({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioFeaturesQueryKey(options)
    });
};

/**
 * Add a feature to the Part Studio's Feature List.
 *
 * The feature is added immediately before the rollback bar. Any geometry IDs specified in the feature must be valid at that point in the feature tree.
 *
 * See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
 */
export const addPartStudioFeatureMutation = (options?: Partial<Options<AddPartStudioFeatureData>>): UseMutationOptions<AddPartStudioFeatureResponse, DefaultError, Options<AddPartStudioFeatureData>> => {
    const mutationOptions: UseMutationOptions<AddPartStudioFeatureResponse, DefaultError, Options<AddPartStudioFeatureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addPartStudioFeature({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Evaluate the FeatureScript snippet for a Part Studio.
 *
 * See [API Guide: Evaluating FeatureScript](https://onshape-public.github.io/docs/api-adv/fs/) for more details.
 *
 * Note that only lambda expressions can be evaulated with this endpoint.
 */
export const evalFeatureScriptMutation = (options?: Partial<Options<EvalFeatureScriptData>>): UseMutationOptions<EvalFeatureScriptResponse, DefaultError, Options<EvalFeatureScriptData>> => {
    const mutationOptions: UseMutationOptions<EvalFeatureScriptResponse, DefaultError, Options<EvalFeatureScriptData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await evalFeatureScript({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFeatureScriptRepresentationQueryKey = (options: Options<GetFeatureScriptRepresentationData>) => createQueryKey('getFeatureScriptRepresentation', options);

/**
 * Get the FeatureScript representation of a Part Studio.
 */
export const getFeatureScriptRepresentationOptions = (options: Options<GetFeatureScriptRepresentationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeatureScriptRepresentation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeatureScriptRepresentationQueryKey(options)
    });
};

export const getPartStudioFeatureSpecsQueryKey = (options: Options<GetPartStudioFeatureSpecsData>) => createQueryKey('getPartStudioFeatureSpecs', options);

/**
 * Get the specs for a Part Studio feature.
 *
 * Returns a list of feature specs available within the Part Studio. A feature spec provides a data description of the feature's interface to a feature.
 */
export const getPartStudioFeatureSpecsOptions = (options: Options<GetPartStudioFeatureSpecsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioFeatureSpecs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioFeatureSpecsQueryKey(options)
    });
};

export const getFeatureScriptTableQueryKey = (options: Options<GetFeatureScriptTableData>) => createQueryKey('getFeatureScriptTable', options);

/**
 * Compute and return a FeatureScript table for a Part Studio.
 */
export const getFeatureScriptTableOptions = (options: Options<GetFeatureScriptTableData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeatureScriptTable({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeatureScriptTableQueryKey(options)
    });
};

export const exportPartStudioGltfQueryKey = (options: Options<ExportPartStudioGltfData>) => createQueryKey('exportPartStudioGltf', options);

/**
 * Synchronously export a Part Studio to a glTF file.
 *
 * Creates a synchronous export of the Part Studio (with limited tessellation settings) to a glTF file.
 * * Returns a 307 redirect from which to download the exported file.
 * * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.
 * * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.
 *
 * See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
 */
export const exportPartStudioGltfOptions = (options: Options<ExportPartStudioGltfData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportPartStudioGltf({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportPartStudioGltfQueryKey(options)
    });
};

/**
 * Find corresponding deterministic IDs from a source document microversion at the target version.
 *
 * * Deterministic IDs are only valid for one microversion.
 * * This maps deterministic IDs between microversions in an attempt to find the corresponding entities in each version.
 */
export const translateIdsMutation = (options?: Partial<Options<TranslateIdsData>>): UseMutationOptions<TranslateIdsResponse, DefaultError, Options<TranslateIdsData>> => {
    const mutationOptions: UseMutationOptions<TranslateIdsResponse, DefaultError, Options<TranslateIdsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await translateIds({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPartStudioMassPropertiesQueryKey = (options: Options<GetPartStudioMassPropertiesData>) => createQueryKey('getPartStudioMassProperties', options);

/**
 * Get the mass properties for a Part Studio.
 *
 * Parts must have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-ps.htm).
 *
 * When three values are returned:
 * * The first is the calculated value.
 * * The second is the minimum possible value, considering tolerance.
 * * The third is the maximum possible value, considering tolerance.
 *
 * See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
 */
export const getPartStudioMassPropertiesOptions = (options: Options<GetPartStudioMassPropertiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioMassProperties({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioMassPropertiesQueryKey(options)
    });
};

export const exportParasolidQueryKey = (options: Options<ExportParasolidData>) => createQueryKey('exportParasolid', options);

/**
 * Synchronously export a Part Studio to a Parasolid file.
 *
 * Creates a synchronous export of the Part Studio (with limited tessellation settings) to a Parasolid file.
 * * Returns a 307 redirect from which to download the exported file.
 * * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.
 * * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.
 *
 * See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
 */
export const exportParasolidOptions = (options: Options<ExportParasolidData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportParasolid({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportParasolidQueryKey(options)
    });
};

export const getPartStudioShadedViewsQueryKey = (options: Options<GetPartStudioShadedViewsData>) => createQueryKey('getPartStudioShadedViews', options);

/**
 * Get a list of shaded views for a Part Studio.
 */
export const getPartStudioShadedViewsOptions = (options: Options<GetPartStudioShadedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioShadedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioShadedViewsQueryKey(options)
    });
};

export const getSketchInfoQueryKey = (options: Options<GetSketchInfoData>) => createQueryKey('getSketchInfo', options);

/**
 * Get information for all sketches in Part Studio.
 */
export const getSketchInfoOptions = (options: Options<GetSketchInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSketchInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSketchInfoQueryKey(options)
    });
};

export const getSketchBoundingBoxesQueryKey = (options: Options<GetSketchBoundingBoxesData>) => createQueryKey('getSketchBoundingBoxes', options);

/**
 * Get all bounding boxes for a sketch.
 */
export const getSketchBoundingBoxesOptions = (options: Options<GetSketchBoundingBoxesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSketchBoundingBoxes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSketchBoundingBoxesQueryKey(options)
    });
};

export const getTessellatedEntitiesQueryKey = (options: Options<GetTessellatedEntitiesData>) => createQueryKey('getTessellatedEntities', options);

/**
 * Get the tessellations of a sketch in a Part Studio.
 *
 * The accuracy of the tessellation to exact geometry is controlled by the `angleTolerance` and `chordTolerance` parameters. The tessellation points are computed closely enough so that neither the angle tolerance nor the chord tolerance are exceeded. For most parts, the angular tolerance is the most restrictive of the two default tolerances.
 */
export const getTessellatedEntitiesOptions = (options: Options<GetTessellatedEntitiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTessellatedEntities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTessellatedEntitiesQueryKey(options)
    });
};

export const exportPartStudioStlQueryKey = (options: Options<ExportPartStudioStlData>) => createQueryKey('exportPartStudioStl', options);

/**
 * Synchronously export a Part Studio to an STL file.
 *
 * Creates a synchronous export of the Part Studio (with limited tessellation settings) to an STL file.
 * * Returns a 307 redirect from which to download the exported file.
 * * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.
 * * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.
 *
 * See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
 */
export const exportPartStudioStlOptions = (options: Options<ExportPartStudioStlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportPartStudioStl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportPartStudioStlQueryKey(options)
    });
};

export const getPartStudioEdgesQueryKey = (options: Options<GetPartStudioEdgesData>) => createQueryKey('getPartStudioEdges', options);

/**
 * Get a list of all edges in a Part Studio.
 *
 * Returns the edges as tessellated data and includes display data.
 * Coordinates are in meters (m).
 */
export const getPartStudioEdgesOptions = (options: Options<GetPartStudioEdgesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioEdges({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioEdgesQueryKey(options)
    });
};

export const getPartStudioFacesQueryKey = (options: Options<GetPartStudioFacesData>) => createQueryKey('getPartStudioFaces', options);

/**
 * Get a list of all faces in a Part Studio.
 *
 * Coordinates are in meters (m).
 */
export const getPartStudioFacesOptions = (options: Options<GetPartStudioFacesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPartStudioFaces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPartStudioFacesQueryKey(options)
    });
};

/**
 * Asynchronously export a Part Studio to glTF.
 *
 * Creates an asynchronous export of a Part Studio to glTF. See [API Guide: Asynchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#export-a-part-studio-to-gltf-obj-solidworks-or-step) for more details.
 */
export const createPartStudioExportGltfMutation = (options?: Partial<Options<CreatePartStudioExportGltfData>>): UseMutationOptions<CreatePartStudioExportGltfResponse, DefaultError, Options<CreatePartStudioExportGltfData>> => {
    const mutationOptions: UseMutationOptions<CreatePartStudioExportGltfResponse, DefaultError, Options<CreatePartStudioExportGltfData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPartStudioExportGltf({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Asynchronously export a Part Studio to OBJ.
 *
 * Creates an asynchronous export of a Part Studio to OBJ. See [API Guide: Asynchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#export-a-part-studio-to-gltf-obj-solidworks-or-step) for more details.
 */
export const createPartStudioExportObjMutation = (options?: Partial<Options<CreatePartStudioExportObjData>>): UseMutationOptions<CreatePartStudioExportObjResponse, DefaultError, Options<CreatePartStudioExportObjData>> => {
    const mutationOptions: UseMutationOptions<CreatePartStudioExportObjResponse, DefaultError, Options<CreatePartStudioExportObjData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPartStudioExportObj({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Asynchronously export a Part Studio to Solidworks.
 *
 * Creates an asynchronous export of a Part Studio to Solidworks. See [API Guide: Asynchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#export-a-part-studio-to-gltf-obj-solidworks-or-step) for more details.
 */
export const createPartStudioExportSolidworksMutation = (options?: Partial<Options<CreatePartStudioExportSolidworksData>>): UseMutationOptions<CreatePartStudioExportSolidworksResponse, DefaultError, Options<CreatePartStudioExportSolidworksData>> => {
    const mutationOptions: UseMutationOptions<CreatePartStudioExportSolidworksResponse, DefaultError, Options<CreatePartStudioExportSolidworksData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPartStudioExportSolidworks({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Asynchronously export a Part Studio to STEP.
 *
 * Creates an asynchronous export of a Part Studio to STEP. See [API Guide: Asynchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#export-a-part-studio-to-gltf-obj-solidworks-or-step) for more details.
 */
export const createPartStudioExportStepMutation = (options?: Partial<Options<CreatePartStudioExportStepData>>): UseMutationOptions<CreatePartStudioExportStepResponse, DefaultError, Options<CreatePartStudioExportStepData>> => {
    const mutationOptions: UseMutationOptions<CreatePartStudioExportStepResponse, DefaultError, Options<CreatePartStudioExportStepData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPartStudioExportStep({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Asynchronously export a Part Studio to another format.
 *
 * Creates an asynchronous export of a Part Studio to another file format.
 * * Can take longer than synchronous export options, but supports more formats and provides more control on tessellation and other settings.
 * * Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats](#/Translation/getAllTranslatorFormats) to get a list of valid export file formats. `
 * * Set `storeInDocument` to `false` to export to a data file. Set to `true` to export to a blob element in the same document.
 * * See [API Guide: Asynchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#export-a-part-studio-to-another-format) for more details.
 */
export const createPartStudioTranslationMutation = (options?: Partial<Options<CreatePartStudioTranslationData>>): UseMutationOptions<CreatePartStudioTranslationResponse, DefaultError, Options<CreatePartStudioTranslationData>> => {
    const mutationOptions: UseMutationOptions<CreatePartStudioTranslationResponse, DefaultError, Options<CreatePartStudioTranslationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPartStudioTranslation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new publication.
 */
export const createPublicationMutation = (options?: Partial<Options<CreatePublicationData>>): UseMutationOptions<CreatePublicationResponse, DefaultError, Options<CreatePublicationData>> => {
    const mutationOptions: UseMutationOptions<CreatePublicationResponse, DefaultError, Options<CreatePublicationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPublication({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a publication.
 */
export const deletePublicationMutation = (options?: Partial<Options<DeletePublicationData>>): UseMutationOptions<DeletePublicationResponse, DefaultError, Options<DeletePublicationData>> => {
    const mutationOptions: UseMutationOptions<DeletePublicationResponse, DefaultError, Options<DeletePublicationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePublication({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update publication's attributes name, description, and notes.
 */
export const updatePublicationAttributesMutation = (options?: Partial<Options<UpdatePublicationAttributesData>>): UseMutationOptions<UpdatePublicationAttributesResponse, DefaultError, Options<UpdatePublicationAttributesData>> => {
    const mutationOptions: UseMutationOptions<UpdatePublicationAttributesResponse, DefaultError, Options<UpdatePublicationAttributesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePublicationAttributes({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add an item in a publication.
 */
export const addItemToPublicationMutation = (options?: Partial<Options<AddItemToPublicationData>>): UseMutationOptions<AddItemToPublicationResponse, DefaultError, Options<AddItemToPublicationData>> => {
    const mutationOptions: UseMutationOptions<AddItemToPublicationResponse, DefaultError, Options<AddItemToPublicationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addItemToPublication({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove an item from a publication.
 */
export const deletePublicationItemMutation = (options?: Partial<Options<DeletePublicationItemData>>): UseMutationOptions<DeletePublicationItemResponse, DefaultError, Options<DeletePublicationItemData>> => {
    const mutationOptions: UseMutationOptions<DeletePublicationItemResponse, DefaultError, Options<DeletePublicationItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePublicationItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPublicationItemsQueryKey = (options: Options<GetPublicationItemsData>) => createQueryKey('getPublicationItems', options);

/**
 * Get all items in a publication.
 */
export const getPublicationItemsOptions = (options: Options<GetPublicationItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicationItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicationItemsQueryKey(options)
    });
};

/**
 * Add publication items in bulk.
 */
export const addItemsToPublicationMutation = (options?: Partial<Options<AddItemsToPublicationData>>): UseMutationOptions<AddItemsToPublicationResponse, DefaultError, Options<AddItemsToPublicationData>> => {
    const mutationOptions: UseMutationOptions<AddItemsToPublicationResponse, DefaultError, Options<AddItemsToPublicationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addItemsToPublication({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create an obsoletion package to make an existing revision obsolete.
 */
export const createObsoletionPackageMutation = (options?: Partial<Options<CreateObsoletionPackageData>>): UseMutationOptions<CreateObsoletionPackageResponse, DefaultError, Options<CreateObsoletionPackageData>> => {
    const mutationOptions: UseMutationOptions<CreateObsoletionPackageResponse, DefaultError, Options<CreateObsoletionPackageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createObsoletionPackage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new release package for one or more items.
 *
 * Once a release package is successfully created, use `updateReleasePackage` to update all desired item/package properties, and transition it to the desired state.
 *
 * To add items from other documents, you must select `Allow adding items from other documents` in your [Release management settings](https://cad.onshape.com/help/Content/Plans/release_management_2.htm#rel_candidate_dialog).
 */
export const createReleasePackageMutation = (options?: Partial<Options<CreateReleasePackageData>>): UseMutationOptions<CreateReleasePackageResponse, DefaultError, Options<CreateReleasePackageData>> => {
    const mutationOptions: UseMutationOptions<CreateReleasePackageResponse, DefaultError, Options<CreateReleasePackageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createReleasePackage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getReleasePackageQueryKey = (options: Options<GetReleasePackageData>) => createQueryKey('getReleasePackage', options);

/**
 * Get details about the specified release package.
 */
export const getReleasePackageOptions = (options: Options<GetReleasePackageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getReleasePackage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getReleasePackageQueryKey(options)
    });
};

/**
 * Update the release/obsoletion package/item properties.
 *
 * Use the `wfaction` query param to also perform a workflow transition.
 */
export const updateReleasePackageMutation = (options?: Partial<Options<UpdateReleasePackageData>>): UseMutationOptions<UpdateReleasePackageResponse, DefaultError, Options<UpdateReleasePackageData>> => {
    const mutationOptions: UseMutationOptions<UpdateReleasePackageResponse, DefaultError, Options<UpdateReleasePackageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateReleasePackage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRevisionByPartNumberQueryKey = (options: Options<GetRevisionByPartNumberData>) => createQueryKey('getRevisionByPartNumber', options);

/**
 * Get details for the specified revision.
 *
 * If the `revision` parameter is left blank, the latest revision information is returned. See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-latest-revision-info) for more details.
 */
export const getRevisionByPartNumberOptions = (options: Options<GetRevisionByPartNumberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRevisionByPartNumber({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRevisionByPartNumberQueryKey(options)
    });
};

export const enumerateRevisionsQueryKey = (options: Options<EnumerateRevisionsData>) => createQueryKey('enumerateRevisions', options);

/**
 * Get all revisions for a company.
 *
 * See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-all-revisions) for more details.
 * * Returns a list of `limit` size of all objects per API call.
 * * To get the next set of results, use the `next` URL from the response body.
 * * Do not change any other query parameters during subsequent enumeration.
 * * Persist `after` query param value and use it to begin a fresh enumeration at a later date.
 * * This API can only be called by company admins.
 */
export const enumerateRevisionsOptions = (options: Options<EnumerateRevisionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enumerateRevisions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enumerateRevisionsQueryKey(options)
    });
};

export const enumerateRevisionsInfiniteQueryKey = (options: Options<EnumerateRevisionsData>): QueryKey<Options<EnumerateRevisionsData>> => createQueryKey('enumerateRevisions', options, true);

/**
 * Get all revisions for a company.
 *
 * See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-all-revisions) for more details.
 * * Returns a list of `limit` size of all objects per API call.
 * * To get the next set of results, use the `next` URL from the response body.
 * * Do not change any other query parameters during subsequent enumeration.
 * * Persist `after` query param value and use it to begin a fresh enumeration at a later date.
 * * This API can only be called by company admins.
 */
export const enumerateRevisionsInfiniteOptions = (options: Options<EnumerateRevisionsData>) => {
    return infiniteQueryOptions<EnumerateRevisionsResponse, DefaultError, InfiniteData<EnumerateRevisionsResponse>, QueryKey<Options<EnumerateRevisionsData>>, string | Pick<QueryKey<Options<EnumerateRevisionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<EnumerateRevisionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await enumerateRevisions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enumerateRevisionsInfiniteQueryKey(options)
    });
};

export const getRevisionHistoryInCompanyByElementIdQueryKey = (options: Options<GetRevisionHistoryInCompanyByElementIdData>) => createQueryKey('getRevisionHistoryInCompanyByElementId', options);

/**
 * Get all revisions for an element (tab).
 *
 * See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-latest-revision-info) for more details.
 */
export const getRevisionHistoryInCompanyByElementIdOptions = (options: Options<GetRevisionHistoryInCompanyByElementIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRevisionHistoryInCompanyByElementId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRevisionHistoryInCompanyByElementIdQueryKey(options)
    });
};

export const getRevisionHistoryInCompanyByPartIdQueryKey = (options: Options<GetRevisionHistoryInCompanyByPartIdData>) => createQueryKey('getRevisionHistoryInCompanyByPartId', options);

/**
 * Get all revisions for a part ID.
 *
 * See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-latest-revision-info) for more details.
 */
export const getRevisionHistoryInCompanyByPartIdOptions = (options: Options<GetRevisionHistoryInCompanyByPartIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRevisionHistoryInCompanyByPartId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRevisionHistoryInCompanyByPartIdQueryKey(options)
    });
};

export const getRevisionHistoryInCompanyByPartNumberQueryKey = (options: Options<GetRevisionHistoryInCompanyByPartNumberData>) => createQueryKey('getRevisionHistoryInCompanyByPartNumber', options);

/**
 * Get all revisions for a part number.
 *
 * You can also request `elementType` in addition to `partNumber` since companies may or may not allow drawings to share part numbers with their parts/assemblies. To perform search without `elementType`, use `elementType = -1` (UNKNOWN).  See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-all-revisions) for more details.
 */
export const getRevisionHistoryInCompanyByPartNumberOptions = (options: Options<GetRevisionHistoryInCompanyByPartNumberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRevisionHistoryInCompanyByPartNumber({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRevisionHistoryInCompanyByPartNumberQueryKey(options)
    });
};

/**
 * Delete all revisions for a part number.
 *
 * Only company admins can call this API. All documents that contain or use the part number must be deleted first. This operation cannot be undone.
 */
export const deleteRevisionHistoryMutation = (options?: Partial<Options<DeleteRevisionHistoryData>>): UseMutationOptions<DeleteRevisionHistoryResponse, DefaultError, Options<DeleteRevisionHistoryData>> => {
    const mutationOptions: UseMutationOptions<DeleteRevisionHistoryResponse, DefaultError, Options<DeleteRevisionHistoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRevisionHistory({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllInDocumentQueryKey = (options: Options<GetAllInDocumentData>) => createQueryKey('getAllInDocument', options);

/**
 * Get all revisions for a document.
 *
 * Retrieve a list of all revisions that exist in a document and are owned by the document's owning company.  See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-all-revisions) for more details.
 */
export const getAllInDocumentOptions = (options: Options<GetAllInDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllInDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllInDocumentQueryKey(options)
    });
};

export const getAllInDocumentVersionQueryKey = (options: Options<GetAllInDocumentVersionData>) => createQueryKey('getAllInDocumentVersion', options);

/**
 * Get all revisions for a version.
 *
 * Retrieve a list of all revisions that exist in a document version and are owned by the document's owning company.  See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-all-revisions) for more details.
 */
export const getAllInDocumentVersionOptions = (options: Options<GetAllInDocumentVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllInDocumentVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllInDocumentVersionQueryKey(options)
    });
};

export const getLatestInDocumentOrCompanyQueryKey = (options: Options<GetLatestInDocumentOrCompanyData>) => createQueryKey('getLatestInDocumentOrCompany', options);

/**
 * Get the latest revision information for a part.
 *
 * See [API Guide: Release Management](https://onshape-public.github.io/docs/api-adv/relmgmt/#get-latest-revision-info) for more details. Returns 204 if no revisions are found.
 */
export const getLatestInDocumentOrCompanyOptions = (options: Options<GetLatestInDocumentOrCompanyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestInDocumentOrCompany({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestInDocumentOrCompanyQueryKey(options)
    });
};

/**
 * Sets the part number and description for a standard content component.
 */
export const setCustomParametersMutation = (options?: Partial<Options<SetCustomParametersData>>): UseMutationOptions<SetCustomParametersResponse, DefaultError, Options<SetCustomParametersData>> => {
    const mutationOptions: UseMutationOptions<SetCustomParametersResponse, DefaultError, Options<SetCustomParametersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setCustomParameters({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getParameterValuesForIdQueryKey = (options: Options<GetParameterValuesForIdData>) => createQueryKey('getParameterValuesForId', options);

/**
 * Gets all possible values for each of the standard content parameters.
 */
export const getParameterValuesForIdOptions = (options: Options<GetParameterValuesForIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getParameterValuesForId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getParameterValuesForIdQueryKey(options)
    });
};

export const getStandardContentListQueryKey = (options?: Options<GetStandardContentListData>) => createQueryKey('getStandardContentList', options);

/**
 * List all standard content.
 */
export const getStandardContentListOptions = (options?: Options<GetStandardContentListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStandardContentList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStandardContentListQueryKey(options)
    });
};

/**
 * Create a new properties table template.
 */
export const createTableTemplateMutation = (options?: Partial<Options<CreateTableTemplateData>>): UseMutationOptions<CreateTableTemplateResponse, DefaultError, Options<CreateTableTemplateData>> => {
    const mutationOptions: UseMutationOptions<CreateTableTemplateResponse, DefaultError, Options<CreateTableTemplateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTableTemplate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getByCompanyIdQueryKey = (options: Options<GetByCompanyIdData>) => createQueryKey('getByCompanyId', options);

/**
 * Get all properties table templates available for a company.
 */
export const getByCompanyIdOptions = (options: Options<GetByCompanyIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getByCompanyId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getByCompanyIdQueryKey(options)
    });
};

export const getByDocumentIdQueryKey = (options: Options<GetByDocumentIdData>) => createQueryKey('getByDocumentId', options);

/**
 * Get all table templates that are available to use on the provided document.
 */
export const getByDocumentIdOptions = (options: Options<GetByDocumentIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getByDocumentId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getByDocumentIdQueryKey(options)
    });
};

/**
 * Delete a properties table template.
 */
export const deleteTableTemplateMutation = (options?: Partial<Options<DeleteTableTemplateData>>): UseMutationOptions<DeleteTableTemplateResponse, DefaultError, Options<DeleteTableTemplateData>> => {
    const mutationOptions: UseMutationOptions<DeleteTableTemplateResponse, DefaultError, Options<DeleteTableTemplateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTableTemplate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTableTemplateQueryKey = (options: Options<GetTableTemplateData>) => createQueryKey('getTableTemplate', options);

/**
 * Get a properties table template by template ID.
 */
export const getTableTemplateOptions = (options: Options<GetTableTemplateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTableTemplate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTableTemplateQueryKey(options)
    });
};

export const getActionItemsQueryKey = (options?: Options<GetActionItemsData>) => createQueryKey('getActionItems', options);

/**
 * Lists tasks assigned to the specified user
 *
 * Returns a list of tasks assigneed to the userId specified in the request. Only company admins can view tasks that were not created by them and are not assigned to them.
 */
export const getActionItemsOptions = (options?: Options<GetActionItemsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActionItems({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActionItemsQueryKey(options)
    });
};

export const getActionItemsInfiniteQueryKey = (options?: Options<GetActionItemsData>): QueryKey<Options<GetActionItemsData>> => createQueryKey('getActionItems', options, true);

/**
 * Lists tasks assigned to the specified user
 *
 * Returns a list of tasks assigneed to the userId specified in the request. Only company admins can view tasks that were not created by them and are not assigned to them.
 */
export const getActionItemsInfiniteOptions = (options?: Options<GetActionItemsData>) => {
    return infiniteQueryOptions<GetActionItemsResponse, DefaultError, InfiniteData<GetActionItemsResponse>, QueryKey<Options<GetActionItemsData>>, number | Pick<QueryKey<Options<GetActionItemsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetActionItemsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getActionItems({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActionItemsInfiniteQueryKey(options)
    });
};

/**
 * Create a new task in a draft state.
 */
export const createTaskMutation = (options?: Partial<Options<CreateTaskData>>): UseMutationOptions<CreateTaskResponse, DefaultError, Options<CreateTaskData>> => {
    const mutationOptions: UseMutationOptions<CreateTaskResponse, DefaultError, Options<CreateTaskData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTask({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTaskQueryKey = (options: Options<GetTaskData>) => createQueryKey('getTask', options);

/**
 * Get a task by id.
 */
export const getTaskOptions = (options: Options<GetTaskData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTask({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTaskQueryKey(options)
    });
};

/**
 * Update the task and its properties.
 */
export const updateTaskMutation = (options?: Partial<Options<UpdateTaskData>>): UseMutationOptions<UpdateTaskResponse, DefaultError, Options<UpdateTaskData>> => {
    const mutationOptions: UseMutationOptions<UpdateTaskResponse, DefaultError, Options<UpdateTaskData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTask({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Execute a workflow transition.
 */
export const transitionTaskMutation = (options?: Partial<Options<TransitionTaskData>>): UseMutationOptions<TransitionTaskResponse, DefaultError, Options<TransitionTaskData>> => {
    const mutationOptions: UseMutationOptions<TransitionTaskResponse, DefaultError, Options<TransitionTaskData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await transitionTask({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findQueryKey = (options?: Options<FindData>) => createQueryKey('find', options);

/**
 * Get a list of all teams the current user belongs to.
 */
export const findOptions = (options?: Options<FindData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await find({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findQueryKey(options)
    });
};

export const findInfiniteQueryKey = (options?: Options<FindData>): QueryKey<Options<FindData>> => createQueryKey('find', options, true);

/**
 * Get a list of all teams the current user belongs to.
 */
export const findInfiniteOptions = (options?: Options<FindData>) => {
    return infiniteQueryOptions<FindResponse, DefaultError, InfiniteData<FindResponse>, QueryKey<Options<FindData>>, number | Pick<QueryKey<Options<FindData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<FindData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await find({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findInfiniteQueryKey(options)
    });
};

export const getTeamQueryKey = (options: Options<GetTeamData>) => createQueryKey('getTeam', options);

/**
 * Get team information by team ID.
 */
export const getTeamOptions = (options: Options<GetTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTeamQueryKey(options)
    });
};

export const getMembersQueryKey = (options: Options<GetMembersData>) => createQueryKey('getMembers', options);

/**
 * Get a list of a team's members.
 *
 * Returns a maximum of 20 per page.
 */
export const getMembersOptions = (options: Options<GetMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersQueryKey(options)
    });
};

export const getMembersInfiniteQueryKey = (options: Options<GetMembersData>): QueryKey<Options<GetMembersData>> => createQueryKey('getMembers', options, true);

/**
 * Get a list of a team's members.
 *
 * Returns a maximum of 20 per page.
 */
export const getMembersInfiniteOptions = (options: Options<GetMembersData>) => {
    return infiniteQueryOptions<GetMembersResponse, DefaultError, InfiniteData<GetMembersResponse>, QueryKey<Options<GetMembersData>>, number | Pick<QueryKey<Options<GetMembersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetMembersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getMembers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersInfiniteQueryKey(options)
    });
};

export const getThumbnailForDocumentQueryKey = (options: Options<GetThumbnailForDocumentData>) => createQueryKey('getThumbnailForDocument', options);

/**
 * Get the thumbnail info for a document in the default workspace.
 *
 * * By default, returns thumbnail info for the element with the most-recently generated image. If you pinned an element for the document thumbnail, that element will always be used for the document-level thumbnail, if it exists in the workspace.
 * * The default workspace may vary by user; the image served depends on the signed-in user.
 * * See also: [Tech tip on how to change a document thumbnail in onshape](https://www.onshape.com/en/resource-center/tech-tips/tech-tip-how-to-change-a-document-thumbnail-in-onshape)
 */
export const getThumbnailForDocumentOptions = (options: Options<GetThumbnailForDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThumbnailForDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThumbnailForDocumentQueryKey(options)
    });
};

export const getThumbnailForDocumentAndVersionQueryKey = (options: Options<GetThumbnailForDocumentAndVersionData>) => createQueryKey('getThumbnailForDocumentAndVersion', options);

/**
 * Get the thumbnail info for a version of a document.
 *
 * * By default, returns thumbnail info for the element with the most-recently generated image. If you pinned an element for the document thumbnail, that element will always be used for the document-level thumbnail, if it exists in the workspace.
 * * See also: [Tech tip on how to change a document thumbnail in onshape](https://www.onshape.com/en/resource-center/tech-tips/tech-tip-how-to-change-a-document-thumbnail-in-onshape)
 */
export const getThumbnailForDocumentAndVersionOptions = (options: Options<GetThumbnailForDocumentAndVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThumbnailForDocumentAndVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThumbnailForDocumentAndVersionQueryKey(options)
    });
};

export const getDocumentThumbnailQueryKey = (options: Options<GetDocumentThumbnailData>) => createQueryKey('getDocumentThumbnail', options);

/**
 * Get the thumbnail info for a workspace.
 *
 * * By default, returns thumbnail info for the element with the most-recently generated image. If you pinned an element for the document thumbnail, that element will always be used for the document-level thumbnail, if it exists in the workspace.
 * * See also: [Tech tip on how to change a document thumbnail in onshape](https://www.onshape.com/en/resource-center/tech-tips/tech-tip-how-to-change-a-document-thumbnail-in-onshape)
 */
export const getDocumentThumbnailOptions = (options: Options<GetDocumentThumbnailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentThumbnail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentThumbnailQueryKey(options)
    });
};

export const getElementThumbnailWithApiConfigurationQueryKey = (options: Options<GetElementThumbnailWithApiConfigurationData>) => createQueryKey('getElementThumbnailWithApiConfiguration', options);

/**
 * Get the thumbnail image with the given configuration for an element.
 *
 * Returns the thumbnail image for an element at a specified version, with the given configuration.
 */
export const getElementThumbnailWithApiConfigurationOptions = (options: Options<GetElementThumbnailWithApiConfigurationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getElementThumbnailWithApiConfiguration({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getElementThumbnailWithApiConfigurationQueryKey(options)
    });
};

export const getDocumentThumbnailWithSizeQueryKey = (options: Options<GetDocumentThumbnailWithSizeData>) => createQueryKey('getDocumentThumbnailWithSize', options);

/**
 * Get the thumbnail image with the given size for a document.
 *
 * * By default, returns thumbnail image for the element with the most-recently generated image. If you pinned an element for the document thumbnail, that element will always be used for the document-level thumbnail, if it exists in the workspace.
 * * See also: [Tech tip on how to change a document thumbnail in onshape](https://www.onshape.com/en/resource-center/tech-tips/tech-tip-how-to-change-a-document-thumbnail-in-onshape)
 */
export const getDocumentThumbnailWithSizeOptions = (options: Options<GetDocumentThumbnailWithSizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentThumbnailWithSize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentThumbnailWithSizeQueryKey(options)
    });
};

/**
 * Delete an element's thumbnail.
 *
 * Deletes an application element's thumbnail and images for the given document, workspace or version, and element combination.
 */
export const deleteApplicationThumbnailsMutation = (options?: Partial<Options<DeleteApplicationThumbnailsData>>): UseMutationOptions<DeleteApplicationThumbnailsResponse, DefaultError, Options<DeleteApplicationThumbnailsData>> => {
    const mutationOptions: UseMutationOptions<DeleteApplicationThumbnailsResponse, DefaultError, Options<DeleteApplicationThumbnailsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteApplicationThumbnails({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getElementThumbnailQueryKey = (options: Options<GetElementThumbnailData>) => createQueryKey('getElementThumbnail', options);

/**
 * Get the thumbnail info structure for an element.
 *
 * Returns thumbnail info for the given document, workspace or version, and element.
 */
export const getElementThumbnailOptions = (options: Options<GetElementThumbnailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getElementThumbnail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getElementThumbnailQueryKey(options)
    });
};

/**
 * Set the thumbnail image for an application element.
 *
 * * Allows 3rd-party applications to set thumbnails for their elements.
 * * Application elements can have both primary and secondary thumbnails. A primary thumbnail represents the top-level of the element. A secondary thumbnail can represent sub-components of the element (e.g., a drawing sheet).
 * * To update one or more thumbnails, you must set the overwrite query param to `true` and supply the entire set of thumbnails. All previous thumbnails will be deleted prior to updating the element with the latest images.
 */
export const setApplicationElementThumbnailMutation = (options?: Partial<Options<SetApplicationElementThumbnailData>>): UseMutationOptions<SetApplicationElementThumbnailResponse, DefaultError, Options<SetApplicationElementThumbnailData>> => {
    const mutationOptions: UseMutationOptions<SetApplicationElementThumbnailResponse, DefaultError, Options<SetApplicationElementThumbnailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setApplicationElementThumbnail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getElementThumbnailWithSizeQueryKey = (options: Options<GetElementThumbnailWithSizeData>) => createQueryKey('getElementThumbnailWithSize', options);

/**
 * Get the thumbnail image with the given size for an element.
 */
export const getElementThumbnailWithSizeOptions = (options: Options<GetElementThumbnailWithSizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getElementThumbnailWithSize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getElementThumbnailWithSizeQueryKey(options)
    });
};

export const getThumbnailForDocumentOldQueryKey = (options: Options<GetThumbnailForDocumentOldData>) => createQueryKey('getThumbnailForDocumentOld', options);

/**
 * This endpoint will be deprecated soon. Use `getThumbnailForDocument` instead.
 *
 * This API exists for historical reasons. It uses `/document/` in the path, rather than the standard `/d/` to specify the document.
 */
export const getThumbnailForDocumentOldOptions = (options: Options<GetThumbnailForDocumentOldData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThumbnailForDocumentOld({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThumbnailForDocumentOldQueryKey(options)
    });
};

export const getThumbnailForDocumentAndVersionOldQueryKey = (options: Options<GetThumbnailForDocumentAndVersionOldData>) => createQueryKey('getThumbnailForDocumentAndVersionOld', options);

/**
 * This endpoint will be deprecated soon. Use `getThumbnailForDocumentAndVersion` instead.
 *
 * This API exists for historical reasons. It uses `/document/` in the path, rather than the standard `/d/` to specify the document.
 */
export const getThumbnailForDocumentAndVersionOldOptions = (options: Options<GetThumbnailForDocumentAndVersionOldData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThumbnailForDocumentAndVersionOld({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThumbnailForDocumentAndVersionOldQueryKey(options)
    });
};

export const getDocumentTranslationsQueryKey = (options: Options<GetDocumentTranslationsData>) => createQueryKey('getDocumentTranslations', options);

/**
 * Get information on an in-progress or completed translation by document ID.
 */
export const getDocumentTranslationsOptions = (options: Options<GetDocumentTranslationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentTranslations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentTranslationsQueryKey(options)
    });
};

export const getDocumentTranslationsInfiniteQueryKey = (options: Options<GetDocumentTranslationsData>): QueryKey<Options<GetDocumentTranslationsData>> => createQueryKey('getDocumentTranslations', options, true);

/**
 * Get information on an in-progress or completed translation by document ID.
 */
export const getDocumentTranslationsInfiniteOptions = (options: Options<GetDocumentTranslationsData>) => {
    return infiniteQueryOptions<GetDocumentTranslationsResponse, DefaultError, InfiniteData<GetDocumentTranslationsResponse>, QueryKey<Options<GetDocumentTranslationsData>>, number | Pick<QueryKey<Options<GetDocumentTranslationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetDocumentTranslationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getDocumentTranslations({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentTranslationsInfiniteQueryKey(options)
    });
};

/**
 * Import or upload a CAD file into Onshape, and translate the data into parts or assemblies.
 *
 * The API call may complete before the translation is finished. If `requestState = ACTIVE`, the translation can be polled until the state is either `DONE` or `FAILED`. Alternatively, a webhook callback can be registered for notification of translation completion (requires `Write` scope if `storeInDocument` is `true`).
 *
 * See [API Guide: Import & Export](https://onshape-public.github.io/docs/api-adv/translation/) for examples.
 */
export const createTranslationMutation = (options?: Partial<Options<CreateTranslationData>>): UseMutationOptions<CreateTranslationResponse, DefaultError, Options<CreateTranslationData>> => {
    const mutationOptions: UseMutationOptions<CreateTranslationResponse, DefaultError, Options<CreateTranslationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTranslation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllTranslatorFormatsQueryKey = (options?: Options<GetAllTranslatorFormatsData>) => createQueryKey('getAllTranslatorFormats', options);

/**
 * Get a list of formats this translation can use.
 *
 * Note that we don't necessarily support both import and export for any given format. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
 */
export const getAllTranslatorFormatsOptions = (options?: Options<GetAllTranslatorFormatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTranslatorFormats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTranslatorFormatsQueryKey(options)
    });
};

/**
 * Delete a translation request.
 */
export const deleteTranslationMutation = (options?: Partial<Options<DeleteTranslationData>>): UseMutationOptions<DeleteTranslationResponse, DefaultError, Options<DeleteTranslationData>> => {
    const mutationOptions: UseMutationOptions<DeleteTranslationResponse, DefaultError, Options<DeleteTranslationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTranslation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTranslationQueryKey = (options: Options<GetTranslationData>) => createQueryKey('getTranslation', options);

/**
 * Get information on an in-progress or completed translation by translation ID.
 *
 * When the translation is complete, `requestState` changes from `ACTIVE` to `DONE` or `FAILED`. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
 *
 * When polling for translations to complete, use a reasonable interval (e.g., avoid polling multiple times a second, use an exponential backoff strategy, etc.) or use [Webhooks](/docs/app-dev/webhook). See [Rate Limiting](/docs/api-adv/errors/#429) and [API Limits](/docs/auth/limits) for more information.
 */
export const getTranslationOptions = (options: Options<GetTranslationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTranslation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTranslationQueryKey(options)
    });
};

/**
 * Authenticate a user's Onshape credentials, and create a session.
 *
 * Returned information depends on caller's `OAuth2ReadPll` scope.
 */
export const sessionMutation = (options?: Partial<Options<SessionData>>): UseMutationOptions<SessionResponse, DefaultError, Options<SessionData>> => {
    const mutationOptions: UseMutationOptions<SessionResponse, DefaultError, Options<SessionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await session({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const sessionInfoQueryKey = (options?: Options<SessionInfoData>) => createQueryKey('sessionInfo', options);

/**
 * Get the session information for an authenticated (signed-in) user.
 *
 * Returned information depends on caller's `OAuth2ReadPll` scope.
 */
export const sessionInfoOptions = (options?: Options<SessionInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sessionInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sessionInfoQueryKey(options)
    });
};

export const getUserSettingsCurrentLoggedInUserQueryKey = (options?: Options<GetUserSettingsCurrentLoggedInUserData>) => createQueryKey('getUserSettingsCurrentLoggedInUser', options);

/**
 * Get the user settings for the signed-in user (i.e., you) for the current session.
 *
 * * Non-admins can call this API for their own user ID.
 * * Mouse button settings are contained in `reverseScrollWheelZoomDirection` and `viewManipulationMouseKeyMapping`.
 * * For each action in `viewManipulationMouseKeyMapping`, an array of modifier key/mouse combos is provided that performs that action.
 * * Possible modifier keys include `SHIFT` and `CTRL`.
 * * Possible mouse buttons include `MMB` (middle mouse button), `RMB` (right mouse button), and `SCROLLWHEEL`.
 * * Scrolling forward zooms in, unless `reverseScrollWheelZoomDirection` is set to `true`.
 */
export const getUserSettingsCurrentLoggedInUserOptions = (options?: Options<GetUserSettingsCurrentLoggedInUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSettingsCurrentLoggedInUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSettingsCurrentLoggedInUserQueryKey(options)
    });
};

export const getUserSettingsQueryKey = (options: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

/**
 * Get the user settings for any user in your organization (admins only).
 *
 * * Mouse button settings are contained in `reverseScrollWheelZoomDirection` and `viewManipulationMouseKeyMapping`.
 * * For each action in `viewManipulationMouseKeyMapping`, an array of modifier key/mouse combos is provided that performs that action.
 * * Possible modifier keys include `SHIFT` and `CTRL`.
 * * Possible mouse buttons include `MMB` (middle mouse button), `RMB` (right mouse button), and `SCROLLWHEEL`.
 * * Scrolling forward zooms in, unless `reverseScrollWheelZoomDirection` is set to `true`.
 */
export const getUserSettingsOptions = (options: Options<GetUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSettingsQueryKey(options)
    });
};

/**
 * Assign variables to a Variable Studio
 */
export const setVariablesMutation = (options?: Partial<Options<SetVariablesData>>): UseMutationOptions<SetVariablesResponse, DefaultError, Options<SetVariablesData>> => {
    const mutationOptions: UseMutationOptions<SetVariablesResponse, DefaultError, Options<SetVariablesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setVariables({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Set the Variable Studio references for an element.
 */
export const setVariableStudioReferencesMutation = (options?: Partial<Options<SetVariableStudioReferencesData>>): UseMutationOptions<SetVariableStudioReferencesResponse, DefaultError, Options<SetVariableStudioReferencesData>> => {
    const mutationOptions: UseMutationOptions<SetVariableStudioReferencesResponse, DefaultError, Options<SetVariableStudioReferencesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setVariableStudioReferences({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Set the scope the Variable Studio.
 */
export const setVariableStudioScopeMutation = (options?: Partial<Options<SetVariableStudioScopeData>>): UseMutationOptions<SetVariableStudioScopeResponse, DefaultError, Options<SetVariableStudioScopeData>> => {
    const mutationOptions: UseMutationOptions<SetVariableStudioScopeResponse, DefaultError, Options<SetVariableStudioScopeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await setVariableStudioScope({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new Variable Studio in a document and workspace.
 */
export const createVariableStudioMutation = (options?: Partial<Options<CreateVariableStudioData>>): UseMutationOptions<CreateVariableStudioResponse, DefaultError, Options<CreateVariableStudioData>> => {
    const mutationOptions: UseMutationOptions<CreateVariableStudioResponse, DefaultError, Options<CreateVariableStudioData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createVariableStudio({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVariablesQueryKey = (options: Options<GetVariablesData>) => createQueryKey('getVariables', options);

/**
 * Get the contents of all variable tables in an element.
 */
export const getVariablesOptions = (options: Options<GetVariablesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVariables({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVariablesQueryKey(options)
    });
};

export const getVariableStudioReferencesQueryKey = (options: Options<GetVariableStudioReferencesData>) => createQueryKey('getVariableStudioReferences', options);

/**
 * Get the Variable Studio references for an element.
 */
export const getVariableStudioReferencesOptions = (options: Options<GetVariableStudioReferencesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVariableStudioReferences({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVariableStudioReferencesQueryKey(options)
    });
};

export const getVariableStudioScopeQueryKey = (options: Options<GetVariableStudioScopeData>) => createQueryKey('getVariableStudioScope', options);

/**
 * Get the scope of a Variable Studio.
 */
export const getVariableStudioScopeOptions = (options: Options<GetVariableStudioScopeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVariableStudioScope({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVariableStudioScopeQueryKey(options)
    });
};

export const getAllVersionsQueryKey = (options?: Options<GetAllVersionsData>) => createQueryKey('getAllVersions', options);

/**
 * Get all versions of the Onshape REST APIs.
 */
export const getAllVersionsOptions = (options?: Options<GetAllVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllVersionsQueryKey(options)
    });
};

export const getWebhooksQueryKey = (options?: Options<GetWebhooksData>) => createQueryKey('getWebhooks', options);

/**
 * Get a list of all webhooks registered by a user or company.
 *
 * See [API Guide: Webhooks](https://onshape-public.github.io/docs/app-dev/webhook/) for implementation details.
 */
export const getWebhooksOptions = (options?: Options<GetWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhooksQueryKey(options)
    });
};

export const getWebhooksInfiniteQueryKey = (options?: Options<GetWebhooksData>): QueryKey<Options<GetWebhooksData>> => createQueryKey('getWebhooks', options, true);

/**
 * Get a list of all webhooks registered by a user or company.
 *
 * See [API Guide: Webhooks](https://onshape-public.github.io/docs/app-dev/webhook/) for implementation details.
 */
export const getWebhooksInfiniteOptions = (options?: Options<GetWebhooksData>) => {
    return infiniteQueryOptions<GetWebhooksResponse, DefaultError, InfiniteData<GetWebhooksResponse>, QueryKey<Options<GetWebhooksData>>, number | Pick<QueryKey<Options<GetWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getWebhooks({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhooksInfiniteQueryKey(options)
    });
};

/**
 * Create a new webhook.
 *
 * Click **Callbacks** below for a list of events your app can subscribe to. See [API Guide: Webhooks](https://onshape-public.github.io/docs/app-dev/webhook/) for implementation details.
 */
export const createWebhookMutation = (options?: Partial<Options<CreateWebhookData>>): UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> => {
    const mutationOptions: UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unregister a webhook.
 *
 * See [API Guide: Webhooks](https://onshape-public.github.io/docs/app-dev/webhook/) for implementation details.
 */
export const unregisterWebhookMutation = (options?: Partial<Options<UnregisterWebhookData>>): UseMutationOptions<UnregisterWebhookResponse, DefaultError, Options<UnregisterWebhookData>> => {
    const mutationOptions: UseMutationOptions<UnregisterWebhookResponse, DefaultError, Options<UnregisterWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unregisterWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookQueryKey = (options: Options<GetWebhookData>) => createQueryKey('getWebhook', options);

/**
 * Get webhook info by webhook ID.
 *
 * See [API Guide: Webhooks](https://onshape-public.github.io/docs/app-dev/webhook/) for implementation details.
 */
export const getWebhookOptions = (options: Options<GetWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookQueryKey(options)
    });
};

/**
 * Update a webhook.
 *
 * See [API Guide: Webhooks](https://onshape-public.github.io/docs/app-dev/webhook/) for implementation details.
 */
export const updateWebhookMutation = (options?: Partial<Options<UpdateWebhookData>>): UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> => {
    const mutationOptions: UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Ping a webhook.
 *
 * See [API Guide: Webhooks](https://onshape-public.github.io/docs/app-dev/webhook/) for implementation details.
 */
export const pingWebhookMutation = (options?: Partial<Options<PingWebhookData>>): UseMutationOptions<PingWebhookResponse, DefaultError, Options<PingWebhookData>> => {
    const mutationOptions: UseMutationOptions<PingWebhookResponse, DefaultError, Options<PingWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await pingWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActiveWorkflowsQueryKey = (options?: Options<GetActiveWorkflowsData>) => createQueryKey('getActiveWorkflows', options);

/**
 * Get all active workflows for the currently logged in user's company.
 *
 * Optionally takes a document ID to return all workflows for that document's owning company.
 */
export const getActiveWorkflowsOptions = (options?: Options<GetActiveWorkflowsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActiveWorkflows({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActiveWorkflowsQueryKey(options)
    });
};

export const getAllowedApproversQueryKey = (options: Options<GetAllowedApproversData>) => createQueryKey('getAllowedApprovers', options);

/**
 * Get all identities allowed to be approvers on a workflow object.
 *
 * * Identities can be users and/or teams.
 * * For Enterprise accounts, also includes roles and any aliases that contain allowed users/teams.
 * * Not object- or property-specific.
 * * Used for delegation and company settings.
 */
export const getAllowedApproversOptions = (options: Options<GetAllowedApproversData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllowedApprovers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllowedApproversQueryKey(options)
    });
};

export const enumerateObjectWorkflowsQueryKey = (options: Options<EnumerateObjectWorkflowsData>) => createQueryKey('enumerateObjectWorkflows', options);

/**
 * Enumerate all of a company's workflowable objects.
 *
 * * For example, you can enumerate RELEASES, TASKS, etc in a company by last modified time.
 * * Caller must be a company admin.
 * * Specify `modifiedAfter` and use the `next` URI for complete enumeration.
 */
export const enumerateObjectWorkflowsOptions = (options: Options<EnumerateObjectWorkflowsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enumerateObjectWorkflows({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enumerateObjectWorkflowsQueryKey(options)
    });
};

export const getWorkflowByIdQueryKey = (options: Options<GetWorkflowByIdData>) => createQueryKey('getWorkflowById', options);

/**
 * Lightweight information about the current state of a workflowable object like release package.
 *
 * Caller must be a company admin as this api allows access to all company owned workflowable objects.
 */
export const getWorkflowByIdOptions = (options: Options<GetWorkflowByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkflowById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkflowByIdQueryKey(options)
    });
};

export const getAuditLogQueryKey = (options: Options<GetAuditLogData>) => createQueryKey('getAuditLog', options);

/**
 * Get all audit log entries for a workflowable object.
 */
export const getAuditLogOptions = (options: Options<GetAuditLogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuditLog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuditLogQueryKey(options)
    });
};
